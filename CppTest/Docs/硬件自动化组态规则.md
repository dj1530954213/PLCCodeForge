Project Hollysys: ICS Protocol Reverse Engineering Rule Map

文档版本: v1.3 (V026 Strict, Cleaned)
最后更新: 2026-01-20
当前状态: 规则已纠正, 仍需 golden dump 校验基类链
目标模块: dllDPLogic.dll + AppData.dll + mfc100.dll

1. 已确认的核心事实
1.1 SerializeVersion 固定为 0x26
- CAppGlobalFunc::SetSerilizeVersion(0x26) 只赋值全局变量
- 运行环境 ver=0x26, 所有 >=0x27/0x36/0x39 分支不执行

1.2 MFC 字符串规则必须使用 AfxReadStringLength
- 不是简单的 “len<255 / 0xFF+u16”
- 必须支持 u8 / u16 / u32 三档长度
- 必须支持 Unicode 标记 [0xFF][0xFFFE]

1.3 列表 Count 位宽不统一
- mapping_count: u16
- order_count/channel_count: u32
- 其他列表以 Serialize 代码为准

2. 对象流的基本约束
2.1 调用链为 obj->Serialize(ar)
- 不包含 CRuntimeClass 对象头
- payload 必须从该类 Serialize 期望的第一个字段开始

2.2 基类链必须先序列化
- 至少包含 CDevice
- 可能包含 CModule/CChannel 等中间基类
- 未经 golden dump 验证前, 基类链字段只能标为“候选”

3. MFC 字符串序列化规范 (AfxReadStringLength)
3.1 ANSI/MBCS (GBK)
- len < 0xFF: [u8 len] + bytes
- 0xFF <= len < 0xFFFE: [0xFF][u16 len] + bytes
- len >= 0xFFFE: [0xFF][0xFFFF][u32 len] + bytes

3.2 Unicode (UTF-16LE)
- 前缀 [0xFF][0xFFFE] 表示 Unicode 模式
- 长度规则同 3.1
- 内容为 len 个 u16

4. CModbusSlave::Serialize (ver=0x26) 字节流顺序
4.1 总体顺序 (基类链之后)
1) u8 field_A
2) u32 field_B
3) u32 field_C
4) u32 field_D
5) u32 field_E
6) u32 field_F
7) flags: u8 x4
8) mapping_count: u16
9) mappings: MappingItem * count
10) order_count: u32
11) orders: CModbusOrder * count
12) channel_count: u32
13) channels: CModbusChannel * count
14) extra_len: u16 (ver>=0x17, 0x26 必走)
15) extra_data: bytes

4.2 ver=0x26 下禁用的分支
- ver>=0x39: 不执行
- ver>=0x36 && appver==4: 不执行

5. CModbusOrder::Serialize (ver=0x26) 要点
- ver>=0x16: start_addr/length 为 u32
- ver>=0x27/0x2C/0x30: 不执行
- Order 内部映射列表 count 多为 u32 (需按代码确认)

6. CModbusChannel::Serialize 要点
- 核心字段: u32 offset_val, u8 data_type, u8 bit_offset
- 仍需完整基类链的流布局确认

7. MappingItem 结构 (稳定)
- u32 p1
- u16 p2
- u8  p3
- u16 p4
- u32 blob_len
- blob_len 字节 blob
注意: blob_len 必须等于实际长度

8. 证据: empty_slave.bin (空对象序列化)
8.1 起始为一串 CString (短字符串)
- 包含 "1", "128.0.0.249", "129.0.0.249", "503" 等
- 这些字符串的语义仍需“改值再 dump”对照

8.2 后续出现固定 u32 块
- 0x00000000, 0x00000001, 0xFFFFFFFF, 0xFF000000 等
- 用于校验基类链与字段顺序

9. 待验证清单 (必须用 golden dump 完成)
9.1 CDevice/CModule/CChannel 基类链字段顺序
- Name/ID/Flags/Description 是否紧邻
- 是否存在 padding 或额外字段

9.2 Order/Channel 的语义命名
- 需要“非空样本”来对齐字段含义

10. 实施建议 (Rust 侧)
- 分版本实现: ModbusSlaveV026 / ModbusOrderV026 / ModbusChannelV026
- 不要写 ver>=0x27/0x39 字段
- 字符串前缀必须走 AfxReadStringLength 规则
- Count 位宽必须与 Serialize 代码一致




Project Hollysys: API 注入层规则汇总 (Verified)
状态: ✅ 数据层注入成功 / ⚠️ UI 实时刷新待解决
目标模块: dllDPLogic.dll (VS2010 / MFC 10.0 / MBCS)
关键偏移: 0x59F10 (OnMakeNewLogicData_Slave)
1. 核心机制规则 (Mechanism)
规则 1.1: 上帝函数路径
我们不再进行二进制拼凑，而是通过调用内部导出函数 CHWDataContainer::OnMakeNewLogicData_Slave 来创建设备。
相对偏移 (RVA): 0x59F10 (相对于 dllDPLogic.dll 基址)。
硬编码特征: 内部会调用 libxml2 相关函数，且包含字符串 "MODBUSSLAVE_TCP"。
规则 1.2: 线程亲和性 (Thread Affinity) —— 至关重要
现象: 在后台线程（如控制台线程）直接调用函数会返回 0 (失败)。
原理: MFC 对象依赖线程局部存储 (TLS) 和主消息循环。
解决方案: 必须通过 SetTimer 或 SendMessage 劫持主窗口消息循环，迫使代码在 主 UI 线程 (Main Thread) 中执行。
规则 1.3: 数据与视图分离 (Model-View Separation)
现象: 函数返回 1 (成功)，但界面无变化；保存重启后设备出现。
结论: 注入仅更新了后端数据链表 (Document)，未触发前端树形控件 (View) 的重绘逻辑。
2. 函数原型与调用约定 (Prototype)
规则 2.1: 函数签名（已用运行时断点校验）
code
C++
// 调用约定: __thiscall (ECX 传递 this 指针)
// 返回值: char/bool (1=Success, 0=Fail)
char CHWDataContainer::OnMakeNewLogicData_Slave(
    CString typeName,       // [Arg1] 设备类型名 (By Value, 例: "MODBUSSLAVE_TCP")
    int commID,             // [Arg2] 实测为 1（语义更像 CommID/类型索引，待确认）
    int linkID,             // [Arg3] 实测为 1（语义更像 LinkID/类型索引，待确认）
    int* pOutID,            // [Arg4] 接收新 ID 的指针
    void* pLink,            // [Arg5] CLink* (GetLinkFromNO 获取)
    void* pParent,          // [Arg6] CDevice* (ModbusTCP 实测为 Link 本体)
    CString desc,           // [Arg7] 描述/IP (By Value)
    int count,              // [Arg8] 数量 (固定为 1)
    void* pContext          // [Arg9] 上下文 (通常等于 pParent)
);
规则 2.2: 对象传递 (ABI)
CString: 必须是 Visual Studio 2010 (v100) 编译的 MFC CString。
传递方式: 值传递 (By Value)。在汇编层面表现为将 CString 对象的内容（通常是一个指针）压栈。不能传 char*。
环境: 项目属性必须设置为 Multi-Byte Character Set (MBCS)。
3. 关键参数取值 (Runtime Values)
这些值在软件每次启动时会变化（ASLR/Heap），但在单次运行期间保持有效。
ECX (Instance): CHWDataContainer 的单例或实例地址。
来源: 需通过调试器获取，或逆向 GetThisClass / GetInstance 静态方法。
Parent (Arg5): 挂载点对象。
来源: 当前选中的树节点对象。
Link (Arg6): 协议链接定义对象。
特征: 这是一个关键的配置对象，决定了父子节点的连接关系。
来源: 通常由 Parent 对象持有，或者是一个全局配置表中的固定项。
4. 下一步攻坚方向 (Next Steps)
既然“存盘重启”有效，接下来的唯一任务就是找到**“刷新函数”**。
我们需要找出原程序在调用完 OnMakeNewLogicData_Slave 后，紧接着调用了什么。
通常是以下几类之一：
CView::OnUpdate(NULL, 0, NULL)
CTreeCtrl::InsertItem(...)
CHWFrameContainer::RefreshTree(...)
发送 WM_PAINT 或自定义消息。
建议记录: 既然已经有了这套规则，接下来的工作重心将从“如何注入”转移到“如何刷新”和“如何自动获取 ECX/Parent 地址”。


Project Hollysys: AutoThink 硬件管理方式分析（MCP/IDA 证据）
状态: ✅ 关键链路已确认 / ⚠️ Link 参数语义仍需样本校验
目标模块: dll_DPFrame.dll + dllDPLogic.dll + dllDPSource.dll

1. 总体架构（数据层 vs 视图层）
1.1 CHWContainer 位于 dll_DPFrame.dll，是硬件管理的 UI/控制枢纽
- 负责保存视图指针并触发视图刷新
- 与 CHWFrameContainer 绑定（UpdateView -> UpdataView）

1.2 CHWDataContainer 嵌入在 CHWContainer 内部
- CHWContainer::GetDataContainer 返回 this+584 (0x248)
- 数据层逻辑（创建/插入设备）位于 dllDPLogic.dll

2. 全局实例与 ECX 获取
2.1 全局实例函数
- sub_100DB560 (dll_DPFrame.dll, RVA 0xDB560)
- 实现: 返回 *(CAppGlobalFunc::GetStation() + 0xA7C)
- 该指针可视为全局 CHWContainer*

2.2 ECX 解析
- CHWDataContainer* = CHWContainer* + 584
- OnMakeNewLogicData_Slave 的 ECX 应使用 CHWDataContainer*

3. Parent/Link 解析机制
3.1 Parent (LogicID -> 指针)
- CHWDataContainer::GetDeviceByLogicID (dllDPLogic.dll, RVA 0x50770)
- TreeView 节点 lParam 不保证为 LogicID；UI 路径更常用 `sub_10045E80(LogicID)` 做映射
- ModbusTCP 实测中 `sub_10045E80` 返回 `CModbusTCPLink`，可作为 “Parent/CDevice” 使用

3.2 当前选择 (可替代 TreeView 遍历)
- CHWContainer::GetCurControlIDAndName 读取 this[416] 作为当前控制 ID
- 通过 CHWFrameContainer::GetControlName 获取名称

3.3 Link (索引式查找)
- CHWContainer::GetLinkFromNO (dll_DPFrame.dll, RVA 0x117830)
- 内部忽略 this，直接调用 sub_100DB560 获取全局对象
- 关键行为:
  - 参数 a2/a3/a4 均为 1-based (函数内部先 dec)
  - 使用 [global+0x288] 取结构，再在 +0x84/+0x68 上做链表索引
  - sub_10043690 / sub_10043610 为“按索引取节点”的链表遍历

3.4 LinkIndex 与父链路指针
- CModbusSlave::GetLinkIndex 偏移 +0x7C (124)
- CDPSlave::GetLinkIndex 偏移 +0x84 (132)
- CDPSlave::GetPapaLink 返回偏移 +0x88 的 CDPLink*
- CModbusSlave::GetCommunIndex 返回 this[32] (a2)
- CModbusSlave::GetSubCommunIndex 返回 this[33] (a4)
- 建议映射: a2=CommunIndex, a3=LinkIndex, a4=SubCommunIndex
- CDPSlave::GetCommunIndex 返回 this[44]
- CGateWayDevice::GetCommunIndex 返回 this[43]，GetLinkIndex 返回偏移 +0xA8 (168)

3.5 OnMakeNewLogicData_Slave 实测参数 (ModbusTCP)
- ECX=0x01BFE970 (CHWDataContainer 实例)
- Arg1=`"MODBUSSLAVE_TCP"`
- Arg2=1, Arg3=1
- Arg4=0x1A780B68（pOutID，返回后写入 0x12）
- Arg5=0x11AC2E38（Link 指针，来源 `GetLinkFromNO(1,1,0)`）
- Arg6=0x19190FC0（Parent 指针，来源 `sub_10045E80(LogicID=1)`）
- Arg7=desc (CString*，含 IP/名称信息)
- Arg8=count=1
- Arg9=pContext=0x19190FC0（与 Arg6 相等）
- Arg5/Arg6 同为 `CModbusTCPLink` 类型，但为不同对象

4. 数据创建链路（解释“只更新数据不刷新 UI”）
4.1 调用链
- OnMakeNewLogicData -> OnMakeNewLogicData_Slave -> MakeNewData

4.2 MakeNewData 行为（核心）
- 根据 SourceContainer::GetProcotolIDFormName 分流创建对象
- 创建 CDPSlave / CModbusSlave / CGateWayDevice 等
- 设置 Name/Desc/ID，并插入容器映射表
- 关联 Link (DillInsertLink)、分配偏移 (AssignSlaveOffset_DP)、创建通道变量
- 调用 CBaseDPContainer::SetModifyLogic 标记数据层变更

5. 刷新路径详解（UI Tree + 映射）
5.1 UpdateView（仅刷新视图，不补映射）
- CHWContainer::UpdateView 仅调用 CHWFrameContainer::UpdataView(this+1600, a2)
- 不会插 TreeItem，也不会写 TreeItem<->ID 映射

5.2 AddNodeToCfgTree（手动插树）
- CHWContainer::AddNodeToCfgTree 插入 TreeItem（CTreeCtrl::InsertItem）
- 插入后写入 TreeItem<->ID 映射（sub_10149D80 / sub_10149DF0）
- 若设备名为 Caption，会自动生成唯一名称并调用 SetUserName

5.3 OnSlave_Operate（UI 插入核心）
- op=1 新增路径要求 link/device 非空，commIdx/linkIdx >= 1
- 内部会规范化/大写名称，并写 NameMap（sub_1008E4E0）
- 通过 GetProTreeHwnd(1126) 发送消息插树，并 SetModifyUnLogic

5.4 OnDPTree_Slave_Operate（树入口）
- 先 NameMap -> ID（sub_10045E00），再 ID -> Device（sub_10045E80）
- 只有命中 NameMap 才会继续调用 OnSlave_Operate
- 若 NameMap 未写入，会直接返回，不会插树

5.5 OnAddSlave（UI 对话框路径）
- 使用 GetLinkFromNO(a2,a3,0) + GetCommunDeviceFromNO 获取上下文
- 调用 CHWDataContainer::OnMakeNewLogicData(global+584) 创建数据
- 随后通过 sub_10045E80 取设备、更新 NameMap，并向 GetProTreeHwnd(1126) 发刷新消息

5.6 RefreshDPTreeForAdd（需要 CSlot*）
- 入参必须是 CSlot*，使用 slot->id 解析 CPLCDevice，再发树消息
- 无 CSlot 时无法直接调用

5.7 结论
- 仅调用 OnMakeNewLogicData_Slave + UpdateView 无法保证 TreeItem/映射完整
- UI 实时刷新应走 OnAddSlave / OnSlave_Operate / AddNodeToCfgTree 路径
- UI 操作必须在主线程执行（避免 TLS/消息循环问题）

6. Context Resolver 实施建议（去掉 std::cin）
6.1 Global/ECX
- Global = sub_100DB560()
- ECX = Global + 584 (或调用 CHWContainer::GetDataContainer)

6.2 Parent/Link
- Parent: GetCurControlIDAndName -> GetDeviceByLogicID
- Link: 优先 CDPSlave::GetPapaLink；否则取 LinkIndex 并用 GetLinkFromNO(Global, a2, index, a3) 搜索

6.2.1 识别失败时的 fallback
- TreeView lParam 可能不是逻辑 ID（可能是索引/指针），GetDeviceByLogicID 会返回空
- 优先使用 CHWContainer::GetCurControlIDAndName 获取当前控制 ID
- 若仍失败，可用 CHWDataContainer::GetLogicIDFromName(名称) 反查逻辑 ID
- 注意：这些解析逻辑建议在 UI 线程执行（Timer 回调），避免线程亲和性导致闪退

6.3 Inject + Refresh（修订）
- 注入后优先走 UI 入口：OnAddSlave（推荐）或 OnSlave_Operate + NameMap
- 若只调用 UpdateView，树映射不会生成，表现为“保存重开才出现”
- UI 相关调用必须在主线程执行

7. TreeView 定位与结构扫描经验（工程管理树）
目标：在多棵 SysTreeView32 并存时，稳定定位“工程管理”主树，并输出结构用于对照 UI/Accessibility。

7.1 关键现象
- 主窗口下存在多棵 SysTreeView32（例如根为“设备库”“库管理器”等），Spy++ 仅能看到这些同级树。
- Accessibility 可以看到更完整的树结构，但 TreeItem 没有独立 HWND（NativeWindowHandle=0 是正常的）。
- 因此必须通过 TreeView 消息（TVM_GETITEM/TVM_GETNEXTITEM）读取节点文本与结构。

7.2 选择主树的判定策略
1) EnumChildWindows(g_hMainWnd, ...) 枚举所有 SysTreeView32
2) 优先使用 GetDlgCtrlID == 1558（Accessibility 的 AutomationId 对应 Win32 控件 ID）
3) 读取根节点文本：TVM_GETNEXTITEM(TVGN_ROOT) + TVM_GETITEM
4) 读取一级子节点列表，用“任务配置/程序块/功能块/函数/硬件配置/全局变量/数据类型/监视列表/在线追踪”等结构特征确认

7.3 建议输出的 Tree 特征（用于核对）
- hwnd/id/parentTitle/rect/client/count
- root 文本
- root 的一级子节点列表
- 硬件配置节点路径（TreePath）与其一级子节点列表
 - 全树递归输出（TreeDump）用于与 Accessibility 完整结构对齐

7.4 Unicode 读取避免乱码
- GetWindowTextA/TVM_GETITEMA 在中文环境下可能乱码
- 建议改为：
  - GetWindowTextW + UTF-8 输出
  - TVM_GETITEMW + UTF-8 输出
- 只有文本正确，才能可靠比对树结构与 Accessibility 显示

7.5 递归遍历输出建议
- 使用 TVM_GETNEXTITEM(TVGN_ROOT/CHILD/NEXT) 深度优先遍历
- 每个节点输出：depth、handle、text（UTF-8）
- 输出量大时可设置 maxNodes/maxDepth 限制

7.6 结论
通过“控件 ID + 结构特征 + Unicode 读取”的组合，可稳定锁定工程管理树。
后续若 UI 插入失败，需要优先确认当前操作树是否为该主树。
