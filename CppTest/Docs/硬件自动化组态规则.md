Project Hollysys: ICS Protocol Reverse Engineering Rule Map

文档版本: v1.3 (V026 Strict, Cleaned)
最后更新: 2026-01-20
当前状态: 规则已纠正, 仍需 golden dump 校验基类链
目标模块: dllDPLogic.dll + AppData.dll + mfc100.dll

1. 已确认的核心事实
1.1 SerializeVersion 固定为 0x26
- CAppGlobalFunc::SetSerilizeVersion(0x26) 只赋值全局变量
- 运行环境 ver=0x26, 所有 >=0x27/0x36/0x39 分支不执行

1.2 MFC 字符串规则必须使用 AfxReadStringLength
- 不是简单的 “len<255 / 0xFF+u16”
- 必须支持 u8 / u16 / u32 三档长度
- 必须支持 Unicode 标记 [0xFF][0xFFFE]

1.3 列表 Count 位宽不统一
- mapping_count: u16
- order_count/channel_count: u32
- 其他列表以 Serialize 代码为准

2. 对象流的基本约束
2.1 调用链为 obj->Serialize(ar)
- 不包含 CRuntimeClass 对象头
- payload 必须从该类 Serialize 期望的第一个字段开始

2.2 基类链必须先序列化
- 至少包含 CDevice
- 可能包含 CModule/CChannel 等中间基类
- 未经 golden dump 验证前, 基类链字段只能标为“候选”

3. MFC 字符串序列化规范 (AfxReadStringLength)
3.1 ANSI/MBCS (GBK)
- len < 0xFF: [u8 len] + bytes
- 0xFF <= len < 0xFFFE: [0xFF][u16 len] + bytes
- len >= 0xFFFE: [0xFF][0xFFFF][u32 len] + bytes

3.2 Unicode (UTF-16LE)
- 前缀 [0xFF][0xFFFE] 表示 Unicode 模式
- 长度规则同 3.1
- 内容为 len 个 u16

4. CModbusSlave::Serialize (ver=0x26) 字节流顺序
4.1 总体顺序 (基类链之后)
1) u8 field_A
2) u32 field_B
3) u32 field_C
4) u32 field_D
5) u32 field_E
6) u32 field_F
7) flags: u8 x4
8) mapping_count: u16
9) mappings: MappingItem * count
10) order_count: u32
11) orders: CModbusOrder * count
12) channel_count: u32
13) channels: CModbusChannel * count
14) extra_len: u16 (ver>=0x17, 0x26 必走)
15) extra_data: bytes

4.2 ver=0x26 下禁用的分支
- ver>=0x39: 不执行
- ver>=0x36 && appver==4: 不执行

5. CModbusOrder::Serialize (ver=0x26) 要点
- ver>=0x16: start_addr/length 为 u32
- ver>=0x27/0x2C/0x30: 不执行
- Order 内部映射列表 count 多为 u32 (需按代码确认)

6. CModbusChannel::Serialize 要点
- 核心字段: u32 offset_val, u8 data_type, u8 bit_offset
- 仍需完整基类链的流布局确认

7. MappingItem 结构 (稳定)
- u32 p1
- u16 p2
- u8  p3
- u16 p4
- u32 blob_len
- blob_len 字节 blob
注意: blob_len 必须等于实际长度

8. 证据: empty_slave.bin (空对象序列化)
8.1 起始为一串 CString (短字符串)
- 包含 "1", "128.0.0.249", "129.0.0.249", "503" 等
- 这些字符串的语义仍需“改值再 dump”对照

8.2 后续出现固定 u32 块
- 0x00000000, 0x00000001, 0xFFFFFFFF, 0xFF000000 等
- 用于校验基类链与字段顺序

9. 待验证清单 (必须用 golden dump 完成)
9.1 CDevice/CModule/CChannel 基类链字段顺序
- Name/ID/Flags/Description 是否紧邻
- 是否存在 padding 或额外字段

9.2 Order/Channel 的语义命名
- 需要“非空样本”来对齐字段含义

10. 实施建议 (Rust 侧)
- 分版本实现: ModbusSlaveV026 / ModbusOrderV026 / ModbusChannelV026
- 不要写 ver>=0x27/0x39 字段
- 字符串前缀必须走 AfxReadStringLength 规则
- Count 位宽必须与 Serialize 代码一致




Project Hollysys: API 注入层规则汇总 (Verified)
状态: ✅ 数据层注入成功 / ⚠️ UI 实时刷新待解决
目标模块: dllDPLogic.dll (VS2010 / MFC 10.0 / MBCS)
关键偏移: 0x59F10 (OnMakeNewLogicData_Slave)
1. 核心机制规则 (Mechanism)
规则 1.1: 上帝函数路径
我们不再进行二进制拼凑，而是通过调用内部导出函数 CHWDataContainer::OnMakeNewLogicData_Slave 来创建设备。
相对偏移 (RVA): 0x59F10 (相对于 dllDPLogic.dll 基址)。
硬编码特征: 内部会调用 libxml2 相关函数，且包含字符串 "MODBUSSLAVE_TCP"。
规则 1.2: 线程亲和性 (Thread Affinity) —— 至关重要
现象: 在后台线程（如控制台线程）直接调用函数会返回 0 (失败)。
原理: MFC 对象依赖线程局部存储 (TLS) 和主消息循环。
解决方案: 必须通过 SetTimer 或 SendMessage 劫持主窗口消息循环，迫使代码在 主 UI 线程 (Main Thread) 中执行。
规则 1.3: 数据与视图分离 (Model-View Separation)
现象: 函数返回 1 (成功)，但界面无变化；保存重启后设备出现。
结论: 注入仅更新了后端数据链表 (Document)，未触发前端树形控件 (View) 的重绘逻辑。
2. 函数原型与调用约定 (Prototype)
规则 2.1: 函数签名
code
C++
// 调用约定: __thiscall (ECX 传递 this 指针)
// 返回值: char/bool (1=Success, 0=Fail)
char CHWDataContainer::OnMakeNewLogicData_Slave(
    CString name,           // [Arg1] 设备名称 (By Value, 栈上构造)
    unsigned int typeID,    // [Arg2] 类型ID (固定为 1)
    char flag,              // [Arg3] 标志位 (固定为 0)
    unsigned int* pOutID,   // [Arg4] 接收新ID的指针
    void* pParent,          // [Arg5] 父节点对象指针 (CControl*)
    void* pLink,            // [Arg6] 链接对象指针 (CLink*)
    CString desc,           // [Arg7] 描述/IP (By Value)
    unsigned int count,     // [Arg8] 数量 (固定为 1)
    void* pContext          // [Arg9] 上下文 (通常等于 pParent)
);
规则 2.2: 对象传递 (ABI)
CString: 必须是 Visual Studio 2010 (v100) 编译的 MFC CString。
传递方式: 值传递 (By Value)。在汇编层面表现为将 CString 对象的内容（通常是一个指针）压栈。不能传 char*。
环境: 项目属性必须设置为 Multi-Byte Character Set (MBCS)。
3. 关键参数取值 (Runtime Values)
这些值在软件每次启动时会变化（ASLR/Heap），但在单次运行期间保持有效。
ECX (Instance): CHWDataContainer 的单例或实例地址。
来源: 需通过调试器获取，或逆向 GetThisClass / GetInstance 静态方法。
Parent (Arg5): 挂载点对象。
来源: 当前选中的树节点对象。
Link (Arg6): 协议链接定义对象。
特征: 这是一个关键的配置对象，决定了父子节点的连接关系。
来源: 通常由 Parent 对象持有，或者是一个全局配置表中的固定项。
4. 下一步攻坚方向 (Next Steps)
既然“存盘重启”有效，接下来的唯一任务就是找到**“刷新函数”**。
我们需要找出原程序在调用完 OnMakeNewLogicData_Slave 后，紧接着调用了什么。
通常是以下几类之一：
CView::OnUpdate(NULL, 0, NULL)
CTreeCtrl::InsertItem(...)
CHWFrameContainer::RefreshTree(...)
发送 WM_PAINT 或自定义消息。
建议记录: 既然已经有了这套规则，接下来的工作重心将从“如何注入”转移到“如何刷新”和“如何自动获取 ECX/Parent 地址”。