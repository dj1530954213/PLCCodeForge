这些函数构成了完整的调用链：获取实例 -> 获取参数 -> 执行注入。
1. 全局实例获取函数 (The Key)
这是解决“手动输入 ECX”痛点的关键。
函数名 (IDA): sub_100DB560
相对偏移 (RVA): 0xDB560
所属模块: dll_DPFrame.dll
函数原型: void* __cdecl GetGlobalInstance() (无参，返回指针)
功能: 内部调用 CAppGlobalFunc::GetStation()，返回 *(Station + 0xA7C) 的全局实例指针（可能为 CHWContainer/CHWDataContainer）。
用途: 自动获取 ECX。它的返回值将作为所有 __thiscall 函数的第一个参数（this 指针）。
2. 父节点指针查找函数 (ID -> Pointer)
这是解决“ID 32 无法转换”的关键。
函数名 (IDA): CHWDataContainer::GetDeviceByLogicID / sub_10050770
相对偏移 (RVA): 0x50770
所属模块: dllDPLogic.dll
函数原型: CDevice* __thiscall GetDeviceByLogicID(CHWDataContainer* pThis, unsigned int id)
功能: 在内部数组或映射表中查找，将树节点的整数 ID (如 32) 转换为内存中的 CDevice* 或 CControl* 对象指针。
用途: 获取注入函数所需的 pParent (Arg5) 和 pContext (Arg9)。
3. 链路指针查找函数 (ID -> Link)
这是解决“手动输入 Link”痛点的关键。
函数名 (IDA): CHWContainer::GetLinkFromNO
相对偏移 (RVA): 0x117830
所属模块: dll_DPFrame.dll
函数原型: CLink* __thiscall GetLinkFromNO(CHWContainer* pThis, unsigned int a2, unsigned int a3, unsigned int a4)
注：伪代码显示它内部会调用 sub_100DB560（同模块），所以外部调用时 pThis 传刚才获取的实例即可。
功能: 根据父节点 ID，查找该节点所属的通信链路对象 (CLink*)。
用途: 获取注入函数所需的 pLink (Arg6)。
4. 核心注入函数 (The Worker)
执行最终添加操作的函数。
函数名 (IDA): CHWDataContainer::OnMakeNewLogicData_Slave
相对偏移 (RVA): 0x59F10
所属模块: dllDPLogic.dll
函数原型:
code
C++
char __thiscall MakeNewSlave(
    void* pThis,        // ECX (来自 0xDB560)
    CString name,       // 新设备名
    uint typeID,        // 固定 1
    char flag,          // 固定 0
    uint* pOutID,       // 接收新ID
    void* pParent,      // 父对象 (来自 0x50770)
    void* pLink,        // 链路对象 (来自 0x117830)
    CString desc,       // 描述/IP
    uint count,         // 固定 1
    void* pContext      // 上下文 (通常等于 pParent)
);
功能: 在内存数据结构中创建新的 Slave 设备节点。
用途: 执行注入。
总结：自动化调用流程图
有了这份清单，GPT 生成代码的逻辑将非常清晰：
初始化: 调用 0xDB560 -> 拿到 GlobalECX。
准备参数:
传入父节点 ID (如 32) + GlobalECX -> 调用 0x50770 -> 拿到 pParent。
传入父节点 ID + GlobalECX -> 调用 0x117830 -> 拿到 pLink。
执行:
传入 GlobalECX, pParent, pLink -> 调用 0x59F10 -> 完成添加。
收尾:
调用 Windows API (InvalidateRect / Expand) -> 刷新 UI。

---

追加：ETHERNET -> MODBUSTCP_MASTER -> MODBUSSLAVE_TCP 原子化流程

1) 三模块职责与入口（IDA 对应）
- dll_DPFrame.dll（UI/树/入口层）
  - CHWFrameContainer::OnAddProcotol @ 0x101A697A
    - 负责新增协议层节点（如 MODBUSTCP_MASTER）并更新 Tree/NameMap。
    - 调用 CheckProcotolMasterSourceInfoExist / CheckNumForProcotol / CheckRedunForProcotol。
  - CHWFrameContainer::OnAddSlave @ 0x101A7AF0
    - 负责新增从站（设备节点），并在 UI 树中插入节点。
    - 会调用 CHWSourceContainer::ReadModChannelInfoToMap 读取 Modbus 通道信息。
  - 校验类：
    - CheckProcotolMasterSourceInfoExist @ 0x101089C0
    - CheckSlaveSourceInfoExist @ 0x10142670
    - CheckNumForProcotol @ 0x10129480

- dllDPLogic.dll（数据层）
  - CHWDataContainer::OnMakeNewLogicData @ 0x1005A720
  - CHWDataContainer::OnMakeNewLogicData_Procotol @ 0x10059E00
  - CHWDataContainer::OnMakeNewLogicData_Slave @ 0x10059F10
  - CHWDataContainer::MakeNewData @ 0x10057490
    - Modbus TCP Slave 对应 case=10，创建 CModbusSlave 并写入地址/Link/Parent。

- dllDPSource.dll（源配置/协议名映射）
  - CHWSourceContainer::GetProcotolIDFormName @ 0x100AA4A0
    - 协议名 -> 协议 ID 的统一映射入口。
  - CHWSourceContainer::ReadModChannelInfoToMap @ 0x100AFE40
    - 读取 Modbus 通道 INI，OnAddSlave 前置条件。

备注：IDA ImageBase 为 0x10000000，上述地址为 IDA 中的 VA。

2) 原子操作 A：新增 MODBUSTCP_MASTER（协议层）
- 入口函数：CHWFrameContainer::OnAddProcotol
- 关键参数：a2 = "MODBUSTCP_MASTER"
- 前置条件：必须在 UI 线程执行；当前树选择需在 ETHERNET 节点
- 预期结果：Tree 插入协议节点 + NameMap/TreeMap 更新

3) 原子操作 B：新增 MODBUSSLAVE_TCP（第三方从站）
- 入口函数：CHWFrameContainer::OnAddSlave
- 关键参数：commIdx/linkIdx、typeName="MODBUSSLAVE_TCP"、desc=IP、count=1、extra=null
- 前置条件：Link/Parent 必须解析到 MODBUSTCP_MASTER 下的上下文
- 预期结果：Tree 插入从站节点 + NameMap 更新

4) 编排流程（建议）
Step1: 选中 ETHERNET 节点 -> 调用 OnAddProcotol("MODBUSTCP_MASTER")
Step2: 通过 TreeScanner/NameMap 定位新 Master 节点并选中
Step3: 重新解析上下文（commIdx/linkIdx/link/parent）
Step4: 调用 OnAddSlave 添加 MODBUSSLAVE_TCP

5) 实现思路（文档版）
- 在 HwHack 中新增 OnAddProcotol 函数指针与 offset，并封装为原子操作 A。
- 原子操作 B 继续沿用现有 OnAddSlave 路径（你们已验证可行）。
- 两个原子操作通过 Timer/UI 线程编排串联，避免 TLS/MFC 线程亲和性问题。

6) 计划（文档版）
Phase1: 落盘上述入口与流程（当前完成）
Phase2: 讨论定位 Master 节点的最稳妥策略（Tree/NameMap/ID 组合）
Phase3: 最终落地代码改动与验证脚本
