这些函数构成了完整的调用链：获取实例 -> 获取参数 -> 执行注入。
1. 全局实例获取函数 (The Key)
这是解决“手动输入 ECX”痛点的关键。
函数名 (IDA): sub_100DB560
相对偏移 (RVA): 0xDB560
所属模块: dll_DPFrame.dll
函数原型: void* __cdecl GetGlobalInstance() (无参，返回指针)
功能: 内部调用 CAppGlobalFunc::GetStation()，返回 *(Station + 0xA7C) 的全局实例指针（可能为 CHWContainer/CHWDataContainer）。
用途: 自动获取 ECX。它的返回值将作为所有 __thiscall 函数的第一个参数（this 指针）。
2. 父节点指针查找函数 (ID -> Pointer)
这是解决“ID 32 无法转换”的关键。
函数名 (IDA): CHWDataContainer::GetDeviceByLogicID / sub_10050770
相对偏移 (RVA): 0x50770
所属模块: dllDPLogic.dll
函数原型: CDevice* __thiscall GetDeviceByLogicID(CHWDataContainer* pThis, unsigned int id)
功能: 在内部数组或映射表中查找，将树节点的整数 ID (如 32) 转换为内存中的 CDevice* 或 CControl* 对象指针。
用途: 获取注入函数所需的 pParent (Arg5) 和 pContext (Arg9)。
3. 链路指针查找函数 (ID -> Link)
这是解决“手动输入 Link”痛点的关键。
函数名 (IDA): CHWContainer::GetLinkFromNO
相对偏移 (RVA): 0x117830
所属模块: dll_DPFrame.dll
函数原型: CLink* __thiscall GetLinkFromNO(CHWContainer* pThis, unsigned int a2, unsigned int a3, unsigned int a4)
注：伪代码显示它内部会调用 sub_100DB560（同模块），所以外部调用时 pThis 传刚才获取的实例即可。
功能: 根据父节点 ID，查找该节点所属的通信链路对象 (CLink*)。
用途: 获取注入函数所需的 pLink (Arg6)。
4. 核心注入函数 (The Worker)
执行最终添加操作的函数。
函数名 (IDA): CHWDataContainer::OnMakeNewLogicData_Slave
相对偏移 (RVA): 0x59F10
所属模块: dllDPLogic.dll
函数原型:
code
C++
char __thiscall MakeNewSlave(
    void* pThis,        // ECX (来自 0xDB560)
    CString name,       // 新设备名
    uint typeID,        // 固定 1
    char flag,          // 固定 0
    uint* pOutID,       // 接收新ID
    void* pParent,      // 父对象 (来自 0x50770)
    void* pLink,        // 链路对象 (来自 0x117830)
    CString desc,       // 描述/IP
    uint count,         // 固定 1
    void* pContext      // 上下文 (通常等于 pParent)
);
功能: 在内存数据结构中创建新的 Slave 设备节点。
用途: 执行注入。
总结：自动化调用流程图
有了这份清单，GPT 生成代码的逻辑将非常清晰：
初始化: 调用 0xDB560 -> 拿到 GlobalECX。
准备参数:
传入父节点 ID (如 32) + GlobalECX -> 调用 0x50770 -> 拿到 pParent。
传入父节点 ID + GlobalECX -> 调用 0x117830 -> 拿到 pLink。
执行:
传入 GlobalECX, pParent, pLink -> 调用 0x59F10 -> 完成添加。
收尾:
调用 Windows API (InvalidateRect / Expand) -> 刷新 UI。
