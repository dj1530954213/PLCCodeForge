use binrw::{binrw, BinResult, BinWrite};
use encoding::all::GBK;
use encoding::{EncoderTrap, Encoding};
use std::fs::File;
use std::io::{Seek, Write};

#[derive(Debug, Clone, Default)]
struct MfcString(String);

impl BinWrite for MfcString {
    type Args<'a> = ();

    fn write_options<W: Seek + Write>(
        &self,
        writer: &mut W,
        endian: binrw::Endian,
        _: Self::Args<'_>,
    ) -> BinResult<()> {
        let bytes = GBK
            .encode(&self.0, EncoderTrap::Strict)
            .unwrap_or_else(|_| self.0.as_bytes().to_vec());

        let len = bytes.len();
        if len < 255 {
            (len as u8).write_options(writer, endian, ())?;
        } else {
            0xFFu8.write_options(writer, endian, ())?;
            (len as u16).write_options(writer, endian, ())?;
        }
        writer.write_all(&bytes)?;
        Ok(())
    }
}

#[binrw]
#[brw(little)]
#[derive(Debug)]
struct DeviceBase {
    #[bw(map = |s| MfcString(s.to_string()))]
    name: String,
    id: u32,
    flag1: u8,
    flag2: u8,
    #[bw(map = |s| MfcString(s.to_string()))]
    description: String,
}

#[binrw]
#[brw(little)]
#[derive(Debug)]
struct MappingItem {
    dummy: u32,
}

#[binrw]
#[brw(little)]
#[derive(Debug)]
struct ModbusOrderConfig {
    base: DeviceBase,
}

#[binrw]
#[brw(little)]
#[derive(Debug)]
struct ModbusChannelConfig {
    base: DeviceBase,
}

#[binrw]
#[brw(little)]
#[derive(Debug)]
struct ModbusSlaveConfig {
    base: DeviceBase,

    #[bw(map = |s| MfcString(s.to_string()))]
    description: String,
    enabled: u8,
    ip_address: u32,
    port: u32,
    timeout: u32,
    retry_count: u32,
    unit_id: u32,

    flags: [u8; 4],

    #[bw(calc = mappings.len() as u16)]
    mapping_count: u16,
    #[br(count = mapping_count)]
    mappings: Vec<MappingItem>,

    #[bw(calc = orders.len() as u32)]
    order_count: u32,
    #[br(count = order_count)]
    orders: Vec<ModbusOrderConfig>,

    #[bw(calc = channels.len() as u32)]
    channel_count: u32,
    #[br(count = channel_count)]
    channels: Vec<ModbusChannelConfig>,

    #[bw(calc = extra_data.len() as u16)]
    extra_data_len: u16,
    #[br(count = extra_data_len)]
    extra_data: Vec<u8>,
}

fn main() -> BinResult<()> {
    let payload = ModbusSlaveConfig {
        base: DeviceBase {
            name: "TCPIO_1_1_192_168_1_100".to_string(),
            id: 0,
            flag1: 1,
            flag2: 1,
            description: "Generated by Rust".to_string(),
        },
        description: "Auto Configured Slave".to_string(),
        enabled: 1,
        ip_address: 0xC0A80164,
        port: 502,
        timeout: 2000,
        retry_count: 3,
        unit_id: 1,
        flags: [0, 0, 0, 0],
        mappings: vec![],
        orders: vec![],
        channels: vec![],
        extra_data: vec![],
    };

    let mut file = File::create("payload.bin")?;
    payload.write(&mut file)?;

    println!("Payload 'payload.bin' generated.");
    println!("Size: {} bytes", file.metadata()?.len());
    Ok(())
}
