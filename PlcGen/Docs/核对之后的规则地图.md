✅ 最新完全版 Rule Map（截至目前所有已知内容整合版 / 去重合并版）
0) 基础通用：Archive / String / Version
0.1 SerializeVersion 来源（已确定）
int CAppGlobalFunc::GetSerilizeVersion() { return dword_10208FB4; }


结论： SerializeVersion 是全局 dword（dword_10208FB4）。

0.2 CString 序列化通用规则（Normal & Safety 共用）
0.2.1 写入长度头：AfxWriteStringLength(ar, len, isUnicode)

若 isUnicode!=0：先写 0xFF 再写 0xFFFE（标记宽字节模式）

然后写长度：

len < 0xFF：写 1 字节 len

len >= 0xFF：先写 0xFF，再：

len < 0xFFFE：写 2 字节 len

len >= 0xFFFE：写 0xFFFF，再写 4 字节 len

len == 0xFFFFFFFF(-1)：写 4 字节 -1，再写 4 字节 -1（异常/特殊占位）

0.2.2 写入字符串内容

不包含 \0

空串：长度头为 0；无 padding

ANSI：写 len 字节

UTF-16LE：写 len*2 字节

0.2.3 读取长度头：AfxReadStringLength(ar, &mode)

初始 *mode=1

先读 1 字节：

若 != 0xFF：返回该字节为长度（mode=1，ANSI）

若 == 0xFF：再读 2 字节：

若 == 0xFFFE：*mode=2（宽字节），再读 1 字节长度；若该字节 !=0xFF 返回它，否则再读 2 字节继续

若 != 0xFFFF：返回该 2 字节为长度

若 == 0xFFFF：再读 4 字节长度；若为 -1 还会再读额外 4 字节并做异常检查

0.2.4 CString Read 封装函数族（sub_10014770 / sub_1001BAA0 / sub_10083D30 等）

等价逻辑：
len = AfxReadStringLength(&mode)；mode==1 读 len，否则读 len*2 并转 CString(char)。
读不满抛 AfxThrowArchiveException(3,0)。

0.3 CArchive::Read/Write 的格式层结论（已确定）

CArchive::Read/Write 仅做缓冲/对齐/底层 I/O，不会插入隐式 marker/padding

Read/Write 前检查读写模式（错误抛异常）

结论： 文件格式只需关心调用层写了什么（<< / >> / WriteObject / WriteCount / Write），无需担心 CArchive 内部改写布局。

1) Normal（普通型）CLDBox（sub_10022A10）
1.1 写入顺序（Storing）

BaseSerialize(sub_100387B0) 后无条件写：

u32 this+356

u32 this+360

u8 this+400

CString this+404

u32 in_count this+292 + in_count * InPin::Serialize()

u32 out_count this+320 + out_count * OutPin::Serialize()

✅ InPins 后立刻 out_count，中间无 marker/padding。

1.2 Loading 版本差异

Loading：SerializeVersion >= 6 才读 this+356/360

Storing：无条件写

✅ 生成器永远写；解析器按版本消费。

2) Normal CLDInPin / CLDOutPin（sub_10048FB0）
2.1 写入顺序（Storing）

u8 f0 @ this+548

u8 f1 @ this+549

CString pin_name @ this+544

CString bind_value @ this+552

u32 binding_id @ this+576（写端无条件写）

2.2 纠偏

FF FF FF FF = 上一条 pin 的 binding_id=-1

后面的 01 00 = 下一条 pin 的 u8+u8

✅ 不存在“共享 record header”。

2.3 binding_id 读取差异

Loading：SerializeVersion >= 13 才读 this+576

✅ 生成器永远写；解析器按版本读。

3) Normal CLDElement Base（sub_100387B0）
3.1 写入顺序（Storing）

u32 ID @ this+4

u8 TypeID @ this+184

CString Name @ this+188

CString Comment @ this+200

CString Desc @ this+204

u32 ConnCount @ this+76

ConnRefs: ConnCount * u32（见 3.2）

✅ Base 不含坐标/尺寸字段。

3.2 ConnRefs 的真实语义（已钉死）

BaseSerialize 写端循环写的是 sub_10037610(connArray, i) 的返回值。

3.2.1 sub_10037610（写端取值）
v2 = this[19];
if (!v2 || i >= v2) return -1;
return *(u32*)(this[18] + 4*i);


this[18] = u32* connRefArray

this[19] = connRefArraySize

越界/无表时落盘 0xFFFFFFFF

3.2.2 sub_100375D0（读端写入）
if (idx >= this[2]) sub_10037470(idx+1, -1);
*(u32*)(this[1] + 4*idx) = value;


自动扩容并用 -1 填充

再写入 connRefArray[idx] = value

✅ 结论：Normal conn 表就是 u32 数组直接落盘（越界写 -1）。

4) Normal CLDNetwork / CLDOr / CLDBracket
4.0 Normal CLDNetwork（sub_100501F0）

BaseSerialize

追加：CString this+54 + CString this+55

4.1 Normal CLDOr（sub_10051150）

Serialize = BaseSerialize only

4.2 Normal CLDBracket（sub_1002CFB0）

BaseSerialize

u8 bracket_type @ +220

u32 field224 @ +224

subobj1 polymorphic @ +232（vtable+8）

u32 count @ +252

count * PinLike::Serialize()（vtable+8）

if bracket_type==2: subobj2 polymorphic @ +228

5) Normal CLDContact（sub_10034920）

BaseSerialize

u8 this+220

CString this+580（operand）

5.x Normal：vtable Serialize 槽位规则 + TextInfo 铁证

Serialize = vtable + 8（index=2）

CElementTextInfo：

vtable+4 = deleting dtor

vtable+8 = nullsub ⇒ Serialize 为 no-op（写 0 字节）

✅ 坐标结论（收口）：已展开的 Base/Network/Contact/Or/Box/TextInfo 均不写坐标 ⇒ Normal 的核心元素数据目前表现为 纯拓扑 ConnRefs（坐标应在其他对象/其他子对象中；若存在）。

6) Safety（安全型）规则（LDMDL）
6.1 Safety::CLDElement Base

Storing：

u32 ID

u8 Type

CString Name（仅 1 串）

u32 ConnCount

ConnIDs: ConnCount * u32

6.2 Safety::CLDNetwork

BaseSerialize(6.1)

CString this[48]

CString this[49]

6.3 Safety::CLDBox

BaseSerialize(6.1)

u8 box_flag

CString instance_name

u32 in_count + InPins

u32 out_count + OutPins

✅ InPins 后立刻 out_count，无 padding。

6.4 Safety::CLDContact

BaseSerialize(6.1)

u8 flag @ this+196

✅ Safety Contact 没有 operand CString。

6.5 Safety::CLDInPin

仅 2 个 CString：

CString @ this+180

CString @ this+184

✅ 无 u8/u16 flag、无 u32 binding_id。

6.6 Safety::CLDOutPin

仅 2 个 CString：

CString @ this+168

CString @ this+172

6.7 Safety::CLDOr / CLDAssign / CLDJump / CLDReturn

都是：Serialize = BaseSerialize only

6.8 Safety::CLDOutput

BaseSerialize(6.1)

u8 @ this+196

u8 @ this+204

7) MFC Object Stream：Class header（WriteClass / Store / Load / ReadClass）

注：class header 是“类层”（WriteClass/ReadClass），与“对象层”WriteObject/ReadObject 是两套 map/id 空间。

7.1 CArchive::WriteClass（确定）

前提检查：

a2 == NULL ⇒ AfxThrowArchiveException(6, …)

ar.IsLoading ⇒ AfxThrowArchiveException(1, …)

a2->m_wSchema == 0xFFFF ⇒ AfxThrowNotSupportedException()

MapObject() 确保 class-map 存在

7.1.1 已出现过该 CRuntimeClass（写“类引用”）

设 id = map[a2]（非 0 表示已登记）：

若 id < 0x7FFF：写 u16( id | 0x8000 )

✅ 最高位 0x8000 表示“class-id 引用”，低 15 位是 id

若 id >= 0x7FFF：

写 u16 0x7FFF

写 u32( id | 0x80000000 )

✅ 0x7FFF 作为扩展哨兵；u32 的最高位 0x80000000 为引用标记

7.1.2 首次出现该 CRuntimeClass（写“类定义”）

写 u16 0xFFFF

调 CRuntimeClass::Store(a2, ar) 写出类信息（见 7.2）

CheckCount(ar) + map[a2] = ar->m_nMapCount; m_nMapCount++

✅ 修正：样本里 FF FF 00 00 ... 应理解为 u16 0xFFFF + 紧随 Store() 的开头字段（schema 常为 0），不再假设存在固定 u32 0xFFFF0000 marker。

7.2 CRuntimeClass::Store / Load（已确定）
7.2.1 Store（写类定义体）

写入顺序：

u16 schema（反编译：*((u16*)this + 4)）

u16 nameLen = lstrlenA(className)

nameLen 字节 ASCII className（不含 \0）

7.2.2 Load（读类定义体）

读入顺序：

读 u16 schema，回传 *a2 = schema

读 u16 nameLen

若 nameLen >= 0x40：失败返回 0

读 nameLen 字节到 char name[64]

若 Read(...) != nameLen：失败返回 0

name[nameLen] = 0

return CRuntimeClass::FromName(name)

✅ 结论：类名最大 63 字节（留 1 字节给 0 终止）。

7.3 CArchive::ReadClass（编码读法要点，已确定）

读端核心：

先读一个 16-bit tag（反编译变量是 void* v18 但 _WORD 使用明确为 u16 语义）

若 tag == 0x7FFF：再读 u32 ext，得到 v5 = ext
否则：v5 = (tag & 0x7FFF) | ((tag & 0x8000) << 16)（把 0x8000 位扩展到 u32 的更高位段）

关键分支：

v5 < 0（最高位为 1） ⇒ 这是 “class 相关” 分支

tag == 0xFFFF ⇒ 新类定义：CRuntimeClass::Load(...)

否则 ⇒ 类引用：按 index 取已注册 runtime class

v5 >= 0 ⇒ 返回 0（无类），并用 a4 回传该值

典型用于对象层的 “引用/NULL” 分支配合（见 12)

8) 最终 Rule Map 汇总（可直接复制）
8.1 CString（通用）

同 0.2

8.2 Normal::CLDElement Base

u32 ID + u8 Type + CString Name + CString Comment + CString Desc + u32 ConnCount + ConnRefs[u32]*

8.3 Normal::CLDBox

Base + u32 + u32 + u8 + CString + u32 in_count + InPins + u32 out_count + OutPins

8.4 Normal::CLDInPin/OutPin

u8 + u8 + CString + CString + u32(binding_id)

8.5 Normal::CLDNetwork

Base + CString + CString

8.6 Normal::CLDContact

Base + u8 + CString(operand)

8.7 Normal：Serialize 槽位 & TextInfo

vtable+8 = Serialize；CElementTextInfo::Serialize = no-op

8.8 Safety::CLDElement Base

u32 ID + u8 Type + CString Name + u32 ConnCount + ConnIDs[u32]*

8.9 Safety::CLDNetwork

Base(8.8) + CString + CString

8.10 Safety::CLDBox

Base(8.8) + u8 + CString + u32 in_count + InPins + u32 out_count + OutPins

8.11 Safety::CLDContact / CLDOutput / Base-only 节点

Safety::CLDContact = Base + u8

Safety::CLDOutput = Base + u8 + u8

Safety::CLDOr/Assign/Jump/Return = Base only

✅ 8.12 CIECPOU / CPOU（已整合：变体 B）
8.12.1 调用关系

CIECPOU::Serialize 仅调用 CPOU::Serialize

8.12.2 CPOU::Serialize（变体 B）新增“前导 u32 时间戳/种子”

写端开头：无条件写 u32 t（来自 _time64() 低 32 位，且 t!=0）

读端读取/跳过条件：

SerializeVersion >= 0x0F：读取该 u32

< 0x0F：

若 ProjectType==1 || CPOU::s_bLibTag || SerializeVersion < 0x0A：不读

否则：读

8.12.3 CPOU::Serialize（变体 B）主字段块顺序

在前导 u32（若读端消费）之后：

CString this+8

CString this+20

u8 this+24

u8 this+25

u32 this[7]

u32 this[9]

u32 this[10]

u32 this[11]

CString this+52

u8 this+32

u32 this+43

u32 this[12]

CString this+56

若 SerializeVersion < 0x44：this+56 = this+52

否则：从 archive 读 CString this+56

8.12.4 CStringArray 块（u32 count + count*CString）

Storing：u32 N=this+22，循环写 N 个 CString

Loading：读 N 次 CString 并 CStringArray::SetAtGrow(this+80, this+22, str)

8.12.5 DB typed-list 块（u32 n + repeat{u8 TypeID + obj->Serialize}）

Storing：写 u32 count = *(this+25)+12，遍历集合写 u8 TypeID + Serialize

Loading：读 u8 TypeID，new 对应 DB 类，Serialize，取 name upper 后插入映射（sub_10036090）

8.12.6 两段 CMemFile blob（ProjectType==1 或 s_bLibTag）

blob1：u32 size1 + bytes[size1]（this+31）

blob2：u32 size2 + bytes[size2]（this+32）

8.12.7 密码/校验块（SerializeVersion>=4）

若 <0x3C：读取两次 16 bytes（共 32 bytes，两段）

否则（>=0x3C）：

u8 this+184

16 bytes -> this+192

16 bytes -> this+208

校验失败：u8 this+224 = 1

写端对应：u8 + 16 + 16

8.12.8 末尾两个 flag（SerializeVersion>=0x29）

u8 this+253

u8 this+254

✅ 8.13 CPOUDetail::Serialize（合并去重版）

结论： 纯 CString 串流；不携带坐标/RECT/POINT/路径点。读端次数由外部初始化 this+20 决定（CLDPOU::Serialize 中确实 Initial 过）。

8.13.1 Loading（ar.IsLoading）

置 this+14 = 1

循环 i=0..this+20-1：

读 CString（sub_10083D30）

CStringArray::SetAtGrow(this+60, this+17, str)

不读取 count：次数固定为 this+20

8.13.2 Storing（ar.IsStoring）

遍历 *(_DWORD**)(this[1]+4) 链

对每个 item：若 item!=0 && *(u8*)(item+20)==1：

sub_100810A0(ar, item) 写出一个 CString（item 的字符串内容）

不写 count：输出数量由过滤条件决定

✅ sub_100810A0 已钉死就是 AfxWriteStringLength + Write(bytes) 的标准 CString 写法（ANSI）。

✅ 8.14 CCrossRecord::Serialize

顺序对称：

CString this+8

u32 this+4

subobject Serialize @ this+12（vtable+8）

✅ 8.15 CLDPOU::Serialize（顶层结构，主链路已钉死）
8.15.1 Storing（写）

CIECPOU::Serialize（= CPOU::Serialize）

构造临时 CObList tmp

遍历内部元素集合（sub_1002E430(&state,&v10,&v11)）：

若 *((u8*)obj + 210) == 0 ⇒ tmp.AddTail(obj)

tmp.Serialize(ar)（见 8.16：Object Stream）

写 CString this+840

写 CString this+552

(*(this+135)->Serialize(vtable+8))(this+135, ar)

注：该对象在你当前样本为 CPOUDetail，已证实是字符串流，不是布局表

8.15.2 Loading（读）

CLDPOU::DelElementClear(this,1)

tmp.Serialize(ar)（见 8.16）

读 CString this+840

读 CString this+552

this+156 = this+552

遍历 v9 链，将对象写入索引：*sub_100348B0(*(obj+4)) = obj

tmp.RemoveAll()

CLDPOU::CalcRelation(this)

CPOUDetail::Initial(this+135, ..., OptionsInfo+480)

(*(this+135)->Serialize(vtable+8))(this+135, ar)

✅ 8.16 CObList::Serialize = MFC Object Stream（Count + WriteObject/ReadObject）
8.16.1 Storing（写）

WriteCount(count=this->m_nCount)

遍历链表节点：WriteObject(node->data)

8.16.2 Loading（读）

count = ReadCount()

循环 count 次：

obj = ReadObject(ar, 0)

AddTail(obj)

✅ 结论：列表落盘是 count + count * ObjectStream(Object)，多态信息由 WriteObject/ReadObject 提供。

9) DB 子块规则（已闭环：TypeID 映射 + 各 DB::Serialize）
✅ 9.1 TypeID 分派：CAppGlobalFunc::GetVarType（已确定）
if IsKindOf(CFunctionBlockDB) return 24;
if IsKindOf(CStructDB)        return 11;
if IsKindOf(CArrayDB)         return 9;
if IsKindOf(CPointerDB)       return 13;
else                          return 21; // CBaseDB

9.2 typed list 通用封装

写：u8 TypeID + obj->Serialize

读：u8 TypeID → new 对应类 → Serialize

未识别 type 会异常/中断分支

9.3 CBaseDB::Serialize（保持原文 + 用 10.3 容器实现补强）

固定字段序列保持原文

this+12 分支：

(path为空 或 suffix==".hlf") && SerializeVersion>=0x11：u32 count + repeat{CString key + CString value}

否则：单一 CString this+12

9.4 CStructDB / CArrayDB / CPointerDB / CFunctionBlockDB

原文 8.18～8.21 保持有效（不改，只在 11 与 10 补强实现依据）。

10) 运行时容器/数组的真实实现（用于同构实现/写端复刻）

✅ 保留你原文结构（不重复扩写）：

✅ 10.1 CStringArray::SetAtGrow / SetSize（字段布局、增长策略 clamp(size/8,4,1024)、扩容初始化、缩小时析构）

✅ 10.2 PairArray8 的 SetSize（8字节元素、memset 0、扩容逻辑同型）

✅ 10.3 KV 哈希容器（HashKey：FNV1a 变体 + 步长采样 len/10+1；Node16：key/value CString + next + hash；插入/删除/清空与 freelist/CPlex 已确定）

11) DB 规则补丁（与容器实现对齐）
11.1 BaseDB this+12 的“语言映射块”

迭代顺序与 bucket/链相关（非排序）

需字节级复刻：复刻 HashKey 与插入顺序

11.2 CArrayDB pair 表

pairCount + repeat(u32,u32) 正确

内部就是 10.2 的 PairArray8

✅ 12) MFC Object Stream（CArchive::WriteObject / ReadObject）（闭环版）
12.1 WriteObject（Storing）规则（已确定）

仅在 ar.IsStoring 合法，否则抛异常

MapObject(ar,0) 确保映射存在

三种情况：

12.1.1 NULL

写 u16 0

12.1.2 已出现对象（写引用 ID）

id = map[obj]

若 id < 0x7FFF：写 u16 id

若 id >= 0x7FFF：写 u16 0x7FFF + u32 id

12.1.3 首次出现对象（写类头 + 内容）

WriteClass(obj->GetRuntimeClass())

首次类：u16 0xFFFF + Store(schema+nameLen+nameBytes)

重复类：写类引用编码（见 7）

CheckCount

记录 object-id：map[obj] = m_nMapCount; m_nMapCount++

obj->Serialize(ar)

✅ 对象层（WriteObject）与类层（WriteClass）各自有独立 map/id 空间。

12.2 ReadObject（Loading）规则（已确定）

仅在 ar.IsLoading 合法，否则抛异常

ReadClass(ar, expectedClass, &schema, &idOrTag) 决定分支

12.2.1 新对象（runtimeClass != NULL）

obj = runtimeClass->CreateObject()；失败抛异常

CheckCount(ar)

将 obj 插入 loadArray（ID→obj）

根据加载状态表处理 schema/状态（反编译体现为状态数组写入 + 保存/恢复 this[4]）

obj->Serialize(ar)

返回 obj

12.2.2 引用已有对象（runtimeClass == NULL）

取 refId = idOrTag

检查 refId 合法；状态不允许（如 “正在加载”）则抛异常

obj = loadArray[refId]

若 caller 给了 expectedClass 且 !obj->IsKindOf(expectedClass)：抛类型不匹配异常

返回 obj

12.3 ReadCount / WriteCount（已确定）

WriteCount(count)：

count < 0xFFFF：写 u16 count

否则：写 u16 0xFFFF 再写 u32 count

ReadCount()：

先读 u16 tmp，若 tmp != 0xFFFF 返回 tmp；否则再读 u32

12.4 由 8.15/8.16 推导的“主解析路径”结论（已确定）

Normal POU 内元素/附属对象主路径：

ReadCount → ReadObject → obj->Serialize

CLDPOU::Factory(type) 仍存在，但不是这条落盘链路的驱动（更可能用于导入/构造/非对象流场景）。

✅ 13) 坐标/布局（当前收口结论）

已展开的多数核心元素 Serialize 不含 x/y/w/h/点集

CLDPOU::Serialize 在对象流后只剩：

CString this+840

CString this+552

this+135 子对象 Serialize

但 this+135 当前样本为 CPOUDetail，已确定为字符串流（变量/文本类信息），不携带坐标/RECT/POINT

因此 若 Normal 存在布局/坐标，目前唯一合理落点是：

Object Stream 列表里尚未识别/尚未反编译的其他对象类（例如 layout/view/route/annotation 类）
（即：坐标不是“元素本体字段”，而是“额外对象类”）

✅（附）本轮新增条目已落盘位置索引

CRuntimeClass::Store/Load：已并入 7.2

CArchive::ReadClass 编码细节：已并入 7.3

ReadCount/WriteCount：已并入 12.3

sub_100810A0（CPOUDetail item = CString 写）：已并入 8.13（并用于确认）

“FF FF 00 00” marker 纠正：已并入 7.1（删除旧推测 marker）


A) CBaseDB 写端（Storing, ar.IsStoring）

从你的反编译来看，写端调用一串 sub_10010320(ar, addr)（可视作“写 CString”或“写某字段（多数是 CString）”的封装），并夹杂若干原始整数/字节写入。

写入顺序（确定）：

sub_10010320(ar, this+4)

sub_10010320(ar, this+8)

sub_10010320(ar, this+12)（但注意：写端先对 this+12 做了 GetStringTOResourceID 的映射处理后再写）

sub_10010320(ar, this+16)

写 u8 this+20

sub_10010320(ar, this+32)

写 u8 this+48

写 u32 this[13]（也就是 *(u32*)(this+52)）

写 u32 this[14]（也就是 *(u32*)(this+56)）

sub_10010320(ar, this+60)

写 u8 this+64

写 u16 this+66（*((WORD*)this+33)）

写 u8 this+69（写端做了 !=0 归一成 0/1）

写 u32 this[19]（*(u32*)(this+76)）

写 u8 this+80

写 u8 this+81（写端同样 !=0 归一）

✅ 这一段非常关键：它告诉你 BaseDB 本体就已经携带了不少“标志位/数值字段”，而不是纯字符串。

B) CBaseDB 读端（Loading）——按 SerializeVersion 的历史兼容路径

你贴出来的结构非常清晰：大体是 SerVer < 0x34 一组旧格式，>=0x34 一组新格式。

B.1 SerializeVersion >= 0x34

依次读取（通过 sub_10011B50 / sub_10014880 / sub_1000FE90 / sub_10012FC0 / sub_1000FF30 / sub_10030230 / sub_10010BC0 这些封装）：

读 this+4

读 this+8

读 this+12

读 this+16

读 this+20

读 this+32

读 this+48

读 this+52

读 this+56

读 this+60

读 this+64

读 this+66

读 this+69

✅ 额外：sub_10012FC0(ar, this+76)（只在 >=0x34 分支里出现）

B.2 SerializeVersion < 0x34

又分 3 段老版本：

0x1B <= ver < 0x34：读到 this+69 后，还会额外 sub_10010BC0(ar, this+69)（看起来是新加的 bool/flag 的兼容读）

0x19 <= ver < 0x1B：字段里出现 this+52 的读取（sub_10012FC0(ar, this+52)）

ver < 0x19：会从 archive 读一个 u16 a2，最后 this[13] = (u16)a2（也就是把旧格式的某个短字段映射到 this+52）

✅ 结论：读端需要严格按版本走，不然会在 this+52/56/69/76 等字段上错位。

C) CBaseDB 读完后的统一后处理（非常重要）

无论走哪个读分支，最后都会执行：

vtable+100(this, 0)

if (SerVer < 0x34): 如果全局 ProjectID / SolidProjectID 有效，会把 this[19]（也就是 this+76）改写成全局 ID（这是运行期 patch，不来自文件）

if (SerVer >= 0x38) 读取 this+80

if (SerVer >= 0x44) 读取 this+81

✅ 这说明：

this+80 是 0x38 新增字段

this+81 是 0x44 新增字段
且它们在写端是无条件写的（你写端确实写了 80/81），符合你“生成器永远写，解析器按版本读”的总策略。

✅ 9.x.2 CStructDB::Serialize（结构体：member typed-list）

你贴的 CStructDB 很干净：

开头 CBaseDB::Serialize(this, ar)

写端（Storing）：

写 u32 this[25]（成员数）

遍历 this[23] 的链表：对每个 member（CBaseDB*）：

写 u8 VarType = GetVarType(member)

member->Serialize(ar)

读端（Loading）：

读 u32 count

循环 count 次：

若 SerVer < 0x2D：直接 new CBaseDB(0x58)（不带 type byte）

否则：读 u8 type，switch：

8 → CStringDB(0x7C)

9 → CArrayDB(0xA4)

11 → CStructDB(0x74)

13 → CPointerDB(0x60)

24 → CFunctionBlockDB(0x118)

default → CBaseDB(0x58)

obj->Serialize(ar)

sub_10020070(obj)（看起来是“加入 DB 索引/注册/去重”的统一入口）

✅ 这块直接把 “typed-list 的读写范式”钉成：
u32 count + repeat{ u8 type + obj }（低版本例外）

✅ 9.x.3 CPointerDB::Serialize（指针：两个字符串 + 版本回填）

先 CBaseDB::Serialize

写端（Storing）：

写 this+88

写 this+92

读端（Loading）：

读 this+88

若 SerVer < 0x44：this+92 = this+88

否则（>=0x44）：再读 this+92；如果 this+92 为空则回填为 this+88

✅ 结论：CPointerDB 在 0x44 版本开始真正落盘第二个字符串字段；旧版本用回填维持行为一致。

✅ 9.x.4 CArrayDB::Serialize（数组：维度 pair 表 + typed-list + 旧版兼容字符串映射）

你的 CArrayDB 很长，但关键结构已经非常清楚了。我按“落盘块”来抽：

A) 头部：继承 CBaseDB::Serialize
B) 维度/Pair 表块（你之前 10.2/11.2 那套被坐实了）

写端：先写一个 u32 this[22]（看起来是 pairCount / dimCount）

然后紧跟 再写一次 u32 this[22]（从你代码看确实有两次写同值的行为：一次通过 sub_10010320/一次直接 raw 写；你实现时要按字节复刻，不要“优化掉”）

然后循环写 pair：每个维度写两个 u32（从 this[24] + 2*v 和 +1 取值）

读端同理：

先读 this[22]

再读 u32 v75（pairCount）

循环 v75 次：读 u32 a, u32 b，调用 sub_1008EEB0(this[25], a, b)（即加入 pair 表）

✅ 这块就是你之前 Rule Map 里“pairCount + repeat(u32,u32)”的铁证升级版：
现在连“读端插入函数”都对上了。

C) 旧版（SerVer < 0x44）维度到字符串的兼容映射

读端里出现了两种路径：

SerVer < 0x44：它会用 Format("%d", pair[i].a/b) 生成两个 CString，再通过 sub_1008F260(this[30], ...) 插入（看起来是 KV/映射容器）

SerVer >= 0x44：直接从 archive 读两段 CString（key/value），再插入 sub_1008F260

✅ 这说明：

0x44 之前：文件里可能 不存 key/value 字符串，而是运行期用数字 pair 格式化生成

0x44 开始：文件里直接存 key/value CString 对

D) typed-list 子对象块

在维度块之后，你能看到：

读 u32 v76（count）

循环 count 次：

SerVer < 0x2D：new CBaseDB

否则：读 u8 type，switch 8/9/11/13/24/21，new 对应类，Serialize

sub_10020070(obj)

写端对应：

写 u32 this[36]（count）

遍历 this[34] 链表：写 u8 type + Serialize

✅ 结论：CArrayDB 内部也嵌套了一段 typed-list（和 StructDB 的 member list 同构）。

✅ 9.x.5 CFunctionBlockDB::Serialize（FB：多段 typed-list + 末尾 KV 映射）

你贴出来的是一个巨型函数，但结构非常明显：它不是“一个 typed-list”，而是“多段 typed-list（至少 5 段以上）+ 最后一段 key/value 映射表”。

A) 写端（Storing）——多段 list

在你贴的后半段（Storing 分支）能看到重复的模式：

写 u32 countX

遍历某个链表 this + 某个index：

写 u8 type

obj->Serialize

这个模式重复出现，分别由这些字段驱动（我用你反编译中出现的下标标记）：

u32 this[25] + list this[23]

u32 this[32] + list this[30]

u32 this[39] + list this[37]

u32 this[46] + list this[44]

u32 this[53] + list this[51]

最后还有一段：

写 u32 this[66]

循环 j=0..this[66)-1：

取一个 CString（来自 this[65] + 4*j 这种数组访问）

写该 CString

再构造另一个 CString（sub_10031520(...) 之类从 key 派生 value）

再写这个派生 CString

✅ 这意味着：FB DB 本体里包含多组“内部成员/接口/变量区块”，每组都是 typed-list。你现在至少能确定“有 5 组 typed-list + 1 组 KV 表”。

B) 读端（Loading）

读端对应的结构也非常清楚：

先读 count1 + typed-list1

再读 count2 + typed-list2

再读 count3 + typed-list3

再读 count4 + typed-list4

再读 count5 + typed-list5

最后读 u32 v135（kvCount）

循环 kvCount 次：读 CString key + CString value

CStringArray::SetAtGrow(...) 保存 key

并把 value 写入一个映射（sub_10031630(key) 找槽，然后 operator=(slot, value)）

✅ 最终结论：CFunctionBlockDB 的变量/接口信息远比 BaseDB/StructDB 更复杂，它本身就是“多 section”。