下面是把**你目前贴出来的所有新增 IDA 源码**（`CStringArray::SetSize/SetAtGrow`、8字节 PairArray 的 `SetSize`、HashKey/哈希表增删查清、`GetSerilizeVersion/GetVarType`、`AfxRead/WriteStringLength`、`CArchive Read/Write/FillBuffer/Flush`）**完整合并**进你这份 Rule Map 后的**最新版全文**（我保留了你原来的结构与编号，并在合适位置补充/加小节；原有内容不删，只做“确定项强化+新增项落盘”）。

---

# 最新完全版 Rule Map（截至目前所有已知内容整合版）

## 0) 基础通用：Archive / String / Version

### 0.1 SerializeVersion 来源（已确定）

* `int CAppGlobalFunc::GetSerilizeVersion() { return dword_10208FB4; }`
* 结论：**SerializeVersion 是一个全局 dword（dword_10208FB4）**，所有 “if SerializeVersion >= X” 都以它为准。

### 0.2 CString 序列化通用规则（Normal & Safety 共用）

#### 0.2.1 写入长度头：AfxWriteStringLength(ar, len, isUnicode)

* 若 `isUnicode!=0`：先写入 `0xFF` 再写 `0xFFFE`（用于标记宽字节模式）。
* 然后写长度：

  * `len < 0xFF`：写 1 字节 `len`
  * `len >= 0xFF`：先写 `0xFF`，再：

    * `len < 0xFFFE`：写 2 字节 `len`
    * `len >= 0xFFFE`：写 `0xFFFF`，再写 4 字节 `len`
    * `len == 0xFFFFFFFF(-1)`：写 4 字节 `-1`，再写 4 字节 `-1`（异常/特殊场景占位）

#### 0.2.2 写入字符串内容

* **不包含 `\0`**
* 空串：长度头为 0；无 padding
* ANSI：写 `len` 字节
* UTF-16LE：写 `len*2` 字节

#### 0.2.3 读取长度头：AfxReadStringLength(ar, &mode)

* 初始化 `*mode=1`
* 先读 1 字节：

  * 若该字节 != `0xFF`：返回它作为长度（mode=1，ANSI）
  * 若该字节 == `0xFF`：再读 2 字节

    * 若 2 字节 == `0xFFFE`：`*mode=2`（宽字节），再读 1 字节长度；若该字节 !=0xFF 返回它，否则再读 2 字节继续
    * 若 2 字节 != `0xFFFF`：返回该 2 字节作为长度
    * 若 2 字节 == `0xFFFF`：再读 4 字节长度；若为 `-1` 还会再读额外 4 字节并做异常检查

#### 0.2.4 CString Read 封装函数（你文档里提到的 sub_10014770 / sub_1001BAA0 等）

* 都等价于：`len=AfxReadStringLength(&mode)`；mode==1读len，否则读len*2 再转 CString(char)。
* 读不满会抛 `AfxThrowArchiveException(3,0)`。

### 0.3 CArchive::Read/Write 的格式层结论（已确定）

* `CArchive::Read/Write` 只是**缓冲/对齐/底层文件 I/O**，不会插入任何隐藏 marker/padding。
* `Read/Write` 前会检查 mode（读/写模式错误会抛 AfxThrowArchiveException）。
* 因此：**文件格式规则只需要关注“你调用了什么 operator<< / operator>> / WriteObject / WriteCount”**，不用担心 CArchive 内部改写布局。

---

# 1) Normal（普通型）CLDBox（sub_10022A10）

## 1.1 写入顺序（Storing）

`BaseSerialize(sub_100387B0)` 后无条件写：

1. `u32 this+356`
2. `u32 this+360`
3. `u8 this+400`
4. `CString this+404`
5. `u32 in_count this+292` + `in_count * InPin::Serialize()`
6. 紧接 `u32 out_count this+320` + `out_count * OutPin::Serialize()`

✅ InPins 后立刻 out_count，中间无 marker/padding。

## 1.2 Loading 版本差异

* Loading：`SerializeVersion >= 6` 才读 `this+356/360`
* 但 Storing 无条件写
  ✅ 生成器：永远写这两个 u32；解析器：按版本消费。

---

# 2) Normal CLDInPin/CLDOutPin（sub_10048FB0）

## 2.1 写入顺序（Storing）

1. `u8 f0 @ this+548`
2. `u8 f1 @ this+549`
3. `CString pin_name @ this+544`
4. `CString bind_value @ this+552`
5. `u32 binding_id @ this+576`（写端无条件写）

## 2.2 纠偏

* `FF FF FF FF` = 上一条 pin 的 `binding_id=-1`
* 后面的 `01 00` = 下一条 pin 的 `u8+u8`
  ✅ 不存在“共享 record header”。

## 2.3 binding_id 的读取差异

* Loading：`SerializeVersion >= 13` 才读 `this+576`
  ✅ 生成器永远写；解析器按版本读。

---

# 3) Normal CLDElement Base（sub_100387B0）

## 3.1 写入顺序（Storing）

1. `u32 ID @ this+4`
2. `u8 TypeID @ this+184`
3. `CString Name @ this+188`
4. `CString Comment @ this+200`
5. `CString Desc @ this+204`
6. `u32 ConnCount @ this+76`
7. `ConnIDs: ConnCount * u32`

✅ Base 不含坐标/尺寸字段。

---

# 4) Normal CLDNetwork / CLDOr / CLDBracket

## 4.0 Normal CLDNetwork（sub_100501F0）

* `BaseSerialize`
* 额外：`CString this+54` + `CString this+55`

## 4.1 Normal CLDOr（sub_10051150）

* `Serialize = BaseSerialize only`

## 4.2 Normal CLDBracket（sub_1002CFB0）

* `BaseSerialize`
* `u8 bracket_type @ +220`
* `u32 field224 @ +224`
* `subobj1 polymorphic @ +232`（vtable+8）
* `u32 count @ +252`
* `count * PinLike::Serialize()`（vtable+8）
* `if bracket_type==2: subobj2 polymorphic @ +228`

---

# 5) Normal CLDContact（sub_10034920）

* `BaseSerialize`
* `u8 this+220`
* `CString this+580`（operand）

---

# 5.x Normal：vtable Serialize 槽位规则 + TextInfo 铁证

* **Serialize = vtable + 8（index=2）**（由多态调用偏移证明）
* `CElementTextInfo`：

  * `vtable+4 = deleting dtor`
  * `vtable+8 = nullsub` ⇒ `Serialize` 为 no-op（写 0 字节）

✅ Normal 坐标结论（收口）：Base/Network/Contact/Or/Box/TextInfo 均不写坐标 ⇒ **Normal 纯拓扑 ConnIDs**。

---

# 6) Safety（安全型）规则（LDMDL）

## 6.1 Safety::CLDElement Base

写入顺序（Storing）：

1. `u32 ID`
2. `u8 Type`
3. `CString Name`（仅 1 串）
4. `u32 ConnCount`
5. `ConnIDs: ConnCount * u32`

## 6.2 Safety::CLDNetwork

* `BaseSerialize(6.1)`
* `CString this[48]`
* `CString this[49]`

## 6.3 Safety::CLDBox

* `BaseSerialize(6.1)`
* `u8 box_flag`
* `CString instance_name`
* `u32 in_count` + `in_count * InPin::Serialize()`（vtable+8）
* 紧接 `u32 out_count` + `out_count * OutPin::Serialize()`（vtable+8）
  ✅ InPins 后立刻 out_count，无 padding/marker。

## 6.4 Safety::CLDContact

* `BaseSerialize(6.1)`
* `u8 flag @ this+196`
  ✅ Safety Contact 没有 operand CString。

## 6.5 Safety::CLDInPin

* 仅 2 个 CString：

  1. `CString @ this+180`
  2. `CString @ this+184`
     ✅ Safety InPin 无 u8/u16 flag、无 u32 binding_id。

## 6.6 Safety::CLDOutPin

* 仅 2 个 CString：

  1. `CString @ this+168`
  2. `CString @ this+172`

## 6.7 Safety::CLDOr / CLDAssign / CLDJump / CLDReturn

* 都是：`Serialize = BaseSerialize only`

## 6.8 Safety::CLDOutput

* `BaseSerialize(6.1)`
* `u8 @ this+196`
* `u8 @ this+204`

---

# 7) 类名签名块（样本侧证，保留限定语）

* `0xFFFF0000`（小端 FF FF 00 00）
* `u16 len`
* `ASCII class_name[len]`
  ⚠️ marker 拆分仍建议用更多样本钉死（u32 vs u16+u16）。

---

# 8) 最终 Rule Map 汇总（可直接复制）

## 8.1 CString（通用）

同 0.2

## 8.2 Normal::CLDElement Base

`u32 ID + u8 Type + CString Name + CString Comment + CString Desc + u32 ConnCount + ConnIDs[u32]*`

## 8.3 Normal::CLDBox

`Base + u32 + u32 + u8 + CString + u32 in_count + InPins + u32 out_count + OutPins`

## 8.4 Normal::CLDInPin/OutPin

`u8 + u8 + CString + CString + u32(binding_id)`

## 8.5 Normal::CLDNetwork

`Base + CString + CString`

## 8.6 Normal::CLDContact

`Base + u8 + CString(operand)`

## 8.7 Normal：Serialize 槽位 & TextInfo

`vtable+8 = Serialize`；`CElementTextInfo::Serialize = no-op`

---

## 8.8 Safety::CLDElement Base

`u32 ID + u8 Type + CString Name + u32 ConnCount + ConnIDs[u32]*`

## 8.9 Safety::CLDNetwork

`Base(8.8) + CString + CString`

## 8.10 Safety::CLDBox

`Base(8.8) + u8 + CString + u32 in_count + InPins + u32 out_count + OutPins`

## 8.11 Safety::CLDContact / CLDOutput / Base-only 节点

* `Safety::CLDContact = Base + u8`
* `Safety::CLDOutput = Base + u8 + u8`
* `Safety::CLDOr/Assign/Jump/Return = Base only`

---

## ✅ 8.12 Safety：CObList::Serialize（MFC Object Stream）

* **Storing**：

  * `CArchive::WriteCount(count)`
  * for each node: `CArchive::WriteObject(obj)`
* **Loading**：

  * `count = CArchive::ReadCount()`
  * loop count: `obj = CArchive::ReadObject()`，`AddTail(obj)`
    ✅ POU 的 element 列表是 **MFC 对象流（带 runtime class/schema）**，不是简单数组。

---

## ✅ 8.13 Safety：CIECPOU / CPOU

### 8.13.1 调用关系

* `CIECPOU::Serialize` 仅调用 `CPOU::Serialize`

### 8.13.2 CPOU 顶层结构（按已确定落盘顺序）

**(A) 先写：**

* `CString this+12`

**(B) 分支块（v3 条件）**

* `v3 == 1`：写若干 KV：`u32 count + repeat(count){ CString key + CString value }`（出现两次同形态块）
* `v3 == 0`：只写 `CString this+20`

**(C) 固定标志/数值段**

* `u8 this+24`
* `u8 this+25`
* `u8 this+26`
* `u32 this[7]`
* `u32 this[9]`
* `u32 this[10]`
* `u32 this[11]`
* `CString this+52`
* `u8 this+32`
* `u32 this+44`
* `u32 this[12]`

**(D) CStringArray 块**

* `u32 count=this+21`
* 循环 count 次：写 CString（数组元素）
* 读：先读 count，再逐个读 CString 并 `SetAtGrow`

**(E) DB/类型库对象块（typed list）**

* 写：`u32 n`；每个对象：`u8 TypeID + obj->Serialize(vtable+8)`
* 读：先读 `u8 TypeID`，按 TypeID new 对应 DB 类，再 Serialize

**(F) 末尾固定两个子对象 Serialize（无条件）**

* `((this+56)->vfunc+8)(..., ar)`
* `(*(this+25)->vfunc+8)(..., ar)`

**(G) 条件附加二进制 blob（CMemFile）**
当 `ProjectType==1 || CPOU::s_bLibTag`：

* 写：`u32 size + raw bytes`（两段：this+29 与 this+32）
* 读：同样读 size + raw bytes，然后 `CMemFile::Attach`

### 8.13.3 u32 读取封装 sub_10006BEA（= ReadU32）

* `sub_10006BEA(ar,&out)` thunk 到 `sub_10020400`
* `sub_10020400`：仅 Loading 合法；从 archive 读 4 字节到 out

### 8.13.4 KV 迭代输出 sub_10006AF0（容器迭代器）

* `sub_10006AF0` thunk 到 `sub_10034A30`
* 行为等价于：从“哈希桶+链”的容器里按迭代状态取出 `(key,value)` 两个 CString，并推进迭代。

---

## ✅ 8.14 Safety：CPOUDetail::Serialize

* **Storing**：遍历集合；若 `*(u8*)(item+20)==1`，写 **一个 CString**
* **Loading**：若 archive 未到末尾，则置 `this+14=1`，然后循环 `this+20` 次：

  * 读 CString（sub_1001BAA0 等价通用 CString read）
  * `CStringArray::SetAtGrow(this+60, this+17, str)`

⚠️ 特征：落盘看似“若干 CString 串流”，读端按 `this+20` 固定次数消费（说明外部数量/结构约束存在）。

---

## ✅ 8.15 Safety：CCrossRecord::Serialize

写入/读取顺序对称：

1. `CString this+8`
2. `u32 this+4`
3. `subobject Serialize @ this+12`（vtable+8）

---

# 9) DB 子块规则（已闭环：TypeID 映射 + 各 DB::Serialize）

## ✅ 9.1 TypeID 分派：CAppGlobalFunc::GetVarType（已确定）

```c
if IsKindOf(CFunctionBlockDB) return 24;
if IsKindOf(CStructDB)        return 11;
if IsKindOf(CArrayDB)         return 9;
if IsKindOf(CPointerDB)       return 13;
else                          return 21; // CBaseDB
```

✅ 这条替换你旧文档里“21 的推测”，现在是**确定值**。

## 9.2 DB 通用封装规则（typed list）

* 写端：`u8 TypeID = GetVarType(dbObj)`；写 1 字节，再 `dbObj->Serialize(ar)`
* 读端：读 `u8 TypeID`；new 对应类；`Serialize(ar)`
* 未识别 type 会触发异常/中断分支（你之前描述保持）。

## 9.3 CBaseDB::Serialize（确定版规则）

> 你文档里 8.17/8.17.2 的内容保留，这里只做“结构不变 + 语言映射块由 Hash 容器实现”的落地补全（见 10.2/10.3 的哈希容器）。

* 固定字段序列（保持你原文 8.17.1）
* 特殊分支 this+12（保持你原文 8.17.2）：

  * 当 `(path为空 或 suffix==".hlf") && SerializeVersion>=0x11`：落盘为 `u32 count + repeat(count){CString key + CString value}`
  * 否则：落盘为单一 `CString this+12`

## 9.4 CStructDB::Serialize / CArrayDB::Serialize / CPointerDB::Serialize / CFunctionBlockDB::Serialize

* 你原文 8.18～8.21 继续有效（此处不改，只在后面补“pair 数组与 CStringArray 的真实 SetSize 行为已确定”，见第 10 节）。

---

# 10) 运行时容器/数组的“真实实现”（用于你做同构内存与写端逻辑）

> 这部分是你这次新增源码带来的“硬落地”：**CStringArray 的布局/扩容**、**8字节 PairArray 的布局/扩容**、以及 **KV 哈希容器的节点布局/HashKey 算法**。
> 文件格式本身不一定需要它，但你要“行为同构/写端复刻”时非常关键。

## ✅ 10.1 CStringArray::SetAtGrow / SetSize（已确定）

### 10.1.1 CStringArray 内部字段布局（32-bit）

```c
struct CStringArray {
  void*  unk0;       // [0] 未用到
  char** m_pData;    // [1] 指针数组，元素4字节
  int    m_nSize;    // [2]
  int    m_nMaxSize; // [3] capacity
  int    m_nGrowBy;  // [4]
};
```

### 10.1.2 SetAtGrow(idx, str)

* idx < 0 抛异常
* idx >= m_nSize ⇒ `SetSize(idx+1, -1)`
* 然后对该元素执行 `CSimpleStringT::SetString(str)`（把 CString 赋值为 str）

### 10.1.3 SetSize(newSize, growBy)

* `newSize < 0` 抛异常
* `growBy >= 0` ⇒ `m_nGrowBy = growBy`
* 若 `newSize==0`：

  * 销毁全部元素（sub_78D04F0F）
  * free 指针数组
  * size/max=0
* 若已有 buffer 且 `newSize > m_nMaxSize`：触发扩容

  * `grow = (m_nGrowBy!=0 ? m_nGrowBy : clamp(m_nSize/8, 4, 1024))`
  * `newMax = max(m_nMaxSize + grow, newSize)`
  * `newBuf = operator new(4*newMax)`
  * 拷贝旧 `4*m_nSize`
  * 对新增区间调用 `sub_78D04EDC(ptr, count)`（等价于“初始化空 CString”）
  * free 旧 buf
  * 更新 `m_nSize=newSize, m_nMaxSize=newMax`
* 若缩小：会对多余元素做销毁（sub_78D04F0F）

✅ 结论：CStringArray 默认增长为 **size/8**（最少 4，最多 1024），属于“分段线性增长”。

---

## ✅ 10.2 8字节 PairArray 的 SetSize（sub_100010F0/sub_1002D1D0）（已确定）

### 10.2.1 对象布局（按偏移）

```c
struct PairArray8 {
  // +0x00 可能有其它字段/vtbl
  void* m_pData;    // +0x04   8字节元素数组
  int   m_nSize;    // +0x08
  int   m_nMax;     // +0x0C
  int   m_nGrowBy;  // +0x10
};
struct Pair8 {
  uint32 a;
  uint32 b; // 反编译里常显示为指针/void*
};
```

### 10.2.2 SetSize(newSize, growBy)

* `newSize < 0` 抛异常
* `growBy >=0` ⇒ 写入 `m_nGrowBy`
* newSize==0：delete[] buffer；size/max=0
* 扩容逻辑与 CStringArray 同型，但元素为 8 字节：

  * `grow = (m_nGrowBy!=0 ? m_nGrowBy : clamp(m_nSize/8,4,1024))`
  * `newMax = max(m_nMax + grow, newSize)`
  * `newBuf = operator new[](8*newMax)`
  * 拷贝旧内容（sub_1000846D，本质 memcpy）
  * 新增区间用 `memset(...,0,...)`
  * delete[] old
* 若只是增大且未超 capacity：对新增区间 `memset 0`
  ✅ 结论：你在 `CArrayDB::Serialize` 里读入的 pair 表，就是 **(u32,u32) 的 POD 动态数组**，新增默认清 0。

---

## ✅ 10.3 KV 哈希容器：HashKey / 查找 / 插入 / 删除 / 清理（已确定）

### 10.3.1 HashKey<char const*>(Str)（已确定）

* 空指针直接抛异常
* 初值 `0x811C9DC5`（-2128831035）
* 乘数 `16777619`
* 但**不是逐字节**：步长为 `len/10 + 1`，即只采样约 10 个点

```c
h = 0x811C9DC5
for (i=0; i<len; i += len/10 + 1)
  h = (h * 16777619) ^ Str[i]
return h
```

### 10.3.2 hashtable 节点布局（与 find/remove 代码对齐）

节点总长 16 字节（32-bit）：

```c
struct HashNode16 {
  CString key;     // +0
  CString value;   // +4
  HashNode16* next;// +8  链指针
  uint32 hash;     // +12
};
```

### 10.3.3 查找：sub_1002BC20(this, key, &bucketIndex, &hashOut)

* `hash = HashKey(key)`
* `bucket = hash % this->bucketCount`
* 遍历 `buckets[bucket]` 链：匹配 `node->hash==hash && node->key==key`

### 10.3.4 插入：sub_1002BFD0(this, key)

* 若 buckets 未分配：按 `this[2]` 分配 `bucketCount` 个 `DWORD` 并清零
* 从 CPlex freelist 分配一个 HashNode16（sub_1002BD90）
* `node->hash = hash`
* 头插到 `buckets[bucket]`

### 10.3.5 删除：sub_10035010(this, key)

* 定位 bucket 链，hash 相等再 Compare key
* unlink 后析构 key/value CString
* 节点回收到 freelist（this[4]）
* 若 this[3]-- 变 0：触发 clear（sub_10001997 / sub_1002BCD0）

### 10.3.6 清空：sub_1002BCD0(this)

* 遍历每个 bucket 的链，析构 key/value
* delete[] buckets
* FreeDataChain(CPlex)

✅ 结论：你文档里所有 “写 u32 count + 循环写 (CString key,CString value)” 的块，其写端基本就是：
**遍历这个哈希容器，把 key/value 依次按 CString 规则写出。**

---

# 11) DB 规则补丁：与本次“容器实现”对齐的说明（不改变格式，只提升确定性）

## 11.1 BaseDB this+12 的“语言映射块”

* 你之前写成“遍历一个哈希容器”——现在容器实现已确定（10.3）。
* 这意味着：

  * 写端的迭代顺序通常受 bucket/链结构影响（不是排序）
  * 若你要“字节级完全复刻”，需复刻 HashKey（10.3.1）与插入顺序
  * 若只要“能读写互通”，顺序通常不影响（除非对方校验 hash/顺序）

## 11.2 CArrayDB 的 pair 表

* 你之前写 pairCount + repeat(u32,u32) 完全正确
* 现在补强：内部就是 10.2 的 PairArray8，新增默认清 0。

---

