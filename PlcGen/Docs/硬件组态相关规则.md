 Project Hollysys: ICS Protocol Reverse Engineering Rule Map
å…ƒæ•°æ®	å†…å®¹
æ–‡æ¡£ç‰ˆæœ¬	v1.2 (Final Release)
æœ€åæ›´æ–°	2026-01-17
å½“å‰çŠ¶æ€	ğŸŸ¢ å…¨é“¾è·¯é€»è¾‘å·²è¿˜åŸ (Slave -> Order -> Channel)
ç›®æ ‡æ¨¡å—	dllDPLogic.dll (æ ¸å¿ƒä¸šåŠ¡é€»è¾‘åº“)
1. æ ¸å¿ƒæ¶æ„ä¸è§„åˆ™æº (Architecture & Sources)
é€šè¿‡é™æ€åˆ†æä¸åŠ¨æ€è°ƒè¯•ï¼Œç¡®è®¤è½¯ä»¶æ•°æ®å­˜å‚¨éµå¾ª MFC åºåˆ—åŒ– (Serialization) æ ‡å‡†ã€‚æ•°æ®ç»“æ„å‘ˆæ ‘çŠ¶é€’å½’å½¢å¼ï¼Œæ‰€æœ‰ç¡¬ä»¶èŠ‚ç‚¹å‡ç»§æ‰¿è‡ªåŸºç±» CDeviceã€‚
è§„åˆ™æ¥æºè¿½è¸ª
é€»è¾‘æ¨¡å—	æ¥æºæ–‡ä»¶	å…³é”®ç±»å	å…³é”®å‡½æ•°	çŠ¶æ€
Header / Base	dllDPLogic.dll	CDevice	Serialize	âœ… å·²è¿˜åŸ
TCP Modbus Slave	dllDPLogic.dll	CModbusSlave	Serialize	âœ… å·²è¿˜åŸ
Modbus Order	dllDPLogic.dll	CModbusOrder	Serialize (1003B1D0)	âœ… å·²è¿˜åŸ
Modbus Channel	dllDPLogic.dll	CModbusChannel	Serialize	âœ… å·²è¿˜åŸ
2. é€šç”¨åºåˆ—åŒ–è§„åˆ™ (General Rules)
åœ¨æ„å»ºäºŒè¿›åˆ¶æµæ—¶ï¼Œå¿…é¡»ä¸¥æ ¼éµå®ˆä»¥ä¸‹ MFC åº•å±‚è§„åˆ™ï¼š
å­—èŠ‚åº: å…¨å±€ Little Endianã€‚
åŸºç±»å¤´éƒ¨: æ‰€æœ‰å¯¹è±¡åœ¨å†™å…¥è‡ªèº«æ•°æ®å‰ï¼Œå¿…é¡»å…ˆå†™å…¥ CDevice çš„æ•°æ®ï¼ˆName, ID, Flags, Descriptionï¼‰ã€‚
CString:
é•¿åº¦ < 255: [Len: u8] + [Bytes]
é•¿åº¦ >= 255: [0xFF] + [Len: u16] + [Bytes]
ç¼–ç : GBK (SimpChinese)ã€‚
CList / é€’å½’åˆ—è¡¨:
æ ¼å¼: [Count: u32] + [Item 1] + [Item 2] ...
å…³é”®: Serialize å‡½æ•°ä¸­ï¼Œåˆ—è¡¨é€šå¸¸æ˜¯é€’å½’è°ƒç”¨çš„ï¼Œå³ Item è‡ªèº«ä¹Ÿæ˜¯ä¸€ä¸ªåŒ…å«å®Œæ•´å¤´éƒ¨çš„å¯¹è±¡ã€‚
3. å®Œæ•´æ•°æ®ç»“æ„å®šä¹‰ (Rust Implementation)
ä»¥ä¸‹ä»£ç æ˜¯æœ€ç»ˆçš„ç»“æ„ä½“å®šä¹‰ï¼Œå¯ä»¥ç›´æ¥ç”¨äºç”Ÿäº§ç¯å¢ƒã€‚
3.1 åŸºç¡€ç±»å‹åº“
code
Rust
use binrw::{binrw, BinRead, BinWrite};

/// MFC String è¾…åŠ©ç»“æ„ (è‡ªåŠ¨å¤„ç†å˜é•¿å‰ç¼€)
#[binrw]
#[derive(Debug, Clone, Default)]
pub struct MfcString {
    #[br(temp)]
    #[bw(calc = if content.len() < 255 { content.len() as u8 } else { 0xFF })]
    len_byte: u8,

    #[br(calc = if len_byte == 0xFF { 0 } else { len_byte as usize })]
    short_len: usize,

    #[br(if(len_byte == 0xFF))]
    #[bw(if(*len_byte == 0xFF))]
    long_len: Option<u16>,

    #[br(count = long_len.map(|x| x as usize).unwrap_or(short_len))]
    #[bw(write_with = |d, w, _, _| w.write_all(d))]
    pub content: Vec<u8>, 
}

/// åŸºç±»: CDevice (æ‰€æœ‰ç¡¬ä»¶å¯¹è±¡çš„å¤´éƒ¨)
/// æ¥æº: CDevice::Serialize
#[binrw]
#[brw(little)]
#[derive(Debug)]
pub struct DeviceBase {
    /// è®¾å¤‡å”¯ä¸€åç§° (å¦‚: TCPIO_1_1_192_168_1_1)
    pub name: MfcString,
    
    /// è®¾å¤‡ ID (é€šå¸¸ç”¨äºå†…éƒ¨ç´¢å¼•ï¼Œæ³¨å…¥æ—¶å¯è®¾ä¸º 0 æˆ–è®¡ç®—å€¼)
    pub id: u32,
    
    /// æ ‡å¿—ä½ 1 (Offset 16)
    pub flag1: u8,
    
    /// æ ‡å¿—ä½ 2 (Offset 18)
    pub flag2: u8,
    
    /// è®¾å¤‡æè¿°/æ³¨é‡Š
    pub description: MfcString,
}
3.2 æ ¸å¿ƒä¸šåŠ¡å¯¹è±¡
code
Rust
// ============================================================================
//  Level 1: Modbus Slave (ä»ç«™è®¾å¤‡)
// ============================================================================
/// æ¥æº: CModbusSlave::Serialize
#[binrw]
#[brw(little)]
#[derive(Debug)]
pub struct ModbusSlaveConfig {
    // 1. åŸºç±»æ•°æ®
    pub base: DeviceBase,

    // 2. è‡ªèº«æ•°æ®
    pub description: MfcString, // Offset 68
    pub enabled: u8,            // Offset 88
    pub ip_address: u32,        // Offset 92 (Hex: C0 A8 01 01)
    pub port: u32,              // Offset 72 (Hex: 39 30 00 00 -> 12345)
    pub timeout: u32,           // Offset 76
    pub retry_count: u32,       // Offset 80
    pub unit_id: u32,           // Offset 84
    
    pub flags: [u8; 4],         // Offsets 96-99 (Padding/Flags)

    // 3. åŠ¨æ€æ˜ å°„æ•°ç»„
    pub mapping_count: u16,     // Offset 100
    #[br(count = mapping_count)]
    pub mappings: Vec<MappingItem>,

    // 4. Modbus Orders (å‘½ä»¤åˆ—è¡¨)
    pub order_count: u32,
    #[br(count = order_count)]
    pub orders: Vec<ModbusOrderConfig>,

    // 5. Modbus Channels (é€šé“åˆ—è¡¨ - é€šå¸¸åœ¨ Slave å±‚çº§ä¸ºç©ºï¼Œä¸»è¦åœ¨ Order ä¸‹)
    pub channel_count: u32,
    #[br(count = channel_count)]
    pub channels: Vec<ModbusChannelConfig>,

    // 6. å°¾éƒ¨æ•°æ® Blob
    pub extra_data_len: u16,
    #[br(count = extra_data_len)]
    pub extra_data: Vec<u8>,
}

// ============================================================================
//  Level 2: Modbus Order (è¯»å†™å‘½ä»¤)
// ============================================================================
/// æ¥æº: CModbusOrder::Serialize
#[binrw]
#[brw(little)]
#[derive(Debug)]
pub struct ModbusOrderConfig {
    // 1. åŸºç±»æ•°æ® (CModule -> CDevice)
    pub base: DeviceBase,

    // 2. æ ¸å¿ƒå±æ€§
    pub func_code_idx: u8, // Offset 140 (03=ReadHold, etc.)
    
    pub start_addr: u32,   // Offset 164
    pub length: u32,       // Offset 168
    pub param3: u16,       // Offset 172
    pub param4: u16,       // Offset 174
    pub param5: u8,        // Offset 160 (æ³¨æ„: åœ¨æµä¸­ä½äº param4 ä¹‹å)
    
    pub scan_period: u32,  // Offset 176
    pub param7: u32,       // Offset 180

    // 3. æ˜ å°„åˆ—è¡¨
    pub map_count: u32,
    #[br(count = map_count)]
    pub mappings: Vec<MappingItem>,

    // 4. å­é€šé“åˆ—è¡¨ (å…·ä½“çš„å˜é‡æ˜ å°„)
    pub channel_count: u32,
    #[br(count = channel_count)]
    pub channels: Vec<ModbusChannelConfig>,
}

// ============================================================================
//  Level 3: Modbus Channel (å…·ä½“çš„å˜é‡/é€šé“)
// ============================================================================
/// æ¥æº: CModbusChannel::Serialize
#[binrw]
#[brw(little)]
#[derive(Debug)]
pub struct ModbusChannelConfig {
    // 1. åŸºç±»æ•°æ® (CChannel -> CDevice)
    pub base: DeviceBase,

    // 2. æ ¸å¿ƒå±æ€§
    /// å˜é‡åç§»åœ°å€ (Offset 56)
    pub offset_val: u32, 
    
    /// æ•°æ®ç±»å‹å®šä¹‰ (Offset 60)
    pub data_type: u8,
    
    /// ä½åç§» (Offset 52)
    pub bit_offset: u8,
}

// ============================================================================
//  è¾…åŠ©: æ˜ å°„é¡¹ Blob
// ============================================================================
#[binrw]
#[brw(little)]
#[derive(Debug)]
pub struct MappingItem {
    pub p1: u32, pub p2: u16, pub p3: u8, pub p4: u16,
    pub blob_len: u32,
    #[br(count = blob_len)]
    pub blob: Vec<u8>,
}
4. å®æ–½é˜¶æ®µï¼šè‡ªåŠ¨åŒ–é…ç½®æˆ˜ç•¥
4.1 æ ¸å¿ƒæˆ˜æœ¯ (The Hybrid Attack)
æˆ‘ä»¬é‡‡ç”¨ "Rust è½½è·ç”Ÿæˆ + C++ åºåˆ—åŒ–æ³¨å…¥" çš„æ¨¡å¼ã€‚è¿™æ˜¯åŸºäºå¯¹ dllDPLogic.dll ä¸­ CPlex å†…å­˜æ± å¤æ‚æ€§çš„è§„é¿ç­–ç•¥ã€‚
4.2 å·¥ä½œæµ (Pipeline)
ç¬¬ä¸€æ­¥ï¼šRust Generator (ç¦»çº¿)
è¾“å…¥: é…ç½®æ–‡ä»¶ (JSON/YAML) å®šä¹‰éœ€è¦çš„ Slave IPã€Order åˆ—è¡¨ã€Channel å˜é‡åã€‚
å¤„ç†: ä½¿ç”¨ä¸Šè¿° ModbusSlaveConfig ç»“æ„ä½“ï¼Œå¡«å……æ•°æ®ã€‚
æ³¨æ„: base.name éœ€è¦æŒ‰ç…§è½¯ä»¶è§„åˆ™ç”Ÿæˆ (å¦‚ TCPIO_1_1_...)ï¼Œå¦åˆ™å¯èƒ½ä¼šå¯¼è‡´ ID å†²çªã€‚
è¾“å‡º: ä¸€ä¸ªçº¯äºŒè¿›åˆ¶æ–‡ä»¶ (Payload.bin)ã€‚
ç¬¬äºŒæ­¥ï¼šC++ Injector (åœ¨çº¿)
ç¼–å†™ä¸€ä¸ªæç®€çš„ DLLï¼Œæ³¨å…¥åˆ°ç»„æ€è½¯ä»¶è¿›ç¨‹ä¸­ï¼Œæ‰§è¡Œä»¥ä¸‹é€»è¾‘ï¼š
code
C++
// ä¼ªä»£ç  - æ³¨å…¥å™¨é€»è¾‘
void InjectConfiguration(char* rawData, int len) {
    // 1. å‡†å¤‡ç¯å¢ƒ
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    // 2. æ„å»ºæ•°æ®æµ
    CMemFile memFile((BYTE*)rawData, len);
    CArchive ar(&memFile, CArchive::load); // Load æ¨¡å¼
    
    // 3. åˆ›å»ºå¯¹è±¡ (Factory Pattern or direct new)
    // éœ€è¦é“¾æ¥åˆ° dllDPLogic.lib æˆ–åŠ¨æ€è·å–ç±»å·¥å‚
    CModbusSlave* pSlave = new CModbusSlave(); 
    
    // 4. ååºåˆ—åŒ– (æ ¸å¿ƒé­”æ³•)
    // è¿™ä¸€æ­¥ä¼šè‡ªåŠ¨é‡å»ºæ‰€æœ‰çš„ Orders å’Œ Channels æ ‘çŠ¶ç»“æ„
    pSlave->Serialize(ar); 
    
    // 5. æŒ‚è½½åˆ°ç³»ç»Ÿ
    // è·å– TCP Manager æŒ‡é’ˆ (0x0084713C)
    void* pManager = *(void**)0x0084713C;
    
    // è°ƒç”¨ AddDriver (Offset +96 in vtable of Manager)
    // pManager->AddDriver(pSlave);
    
    // 6. åˆ·æ–°ç•Œé¢
    // CAppGlobalFunc::UpdateFrameTitle();
}
4.3 æ•…éšœæ’æŸ¥ (Troubleshooting)
å¯¹é½é”™è¯¯: å¦‚æœæ³¨å…¥åè½¯ä»¶å´©æºƒï¼Œæå¤§å¯èƒ½æ˜¯ CDevice å¤´éƒ¨è§£æé”™è¯¯ã€‚è¯·æ£€æŸ¥ Rust ç”Ÿæˆçš„ MfcString é•¿åº¦è®¡ç®—æ˜¯å¦æ­£ç¡®ï¼ˆç‰¹åˆ«æ˜¯ >255 å­—èŠ‚çš„æƒ…å†µï¼‰ã€‚
æ•°æ®æœªæ˜¾ç¤º: å¦‚æœæ³¨å…¥æˆåŠŸä½† UI ä¸æ˜¾ç¤ºï¼Œæ£€æŸ¥ base.flag1 å’Œ base.flag2ã€‚å°è¯•å°†å…¶è®¾ä¸º 0x01 æˆ– 0x00ã€‚
ç«¯å£é”™è¯¯: å†æ¬¡å¼ºè°ƒï¼ŒPort å­—æ®µåœ¨ CModbusSlave ä¸­è¯»å–çš„æ˜¯ 4å­—èŠ‚ (u32)ï¼Œä¸è¦ä¸ºäº†èŠ‚çœç©ºé—´åªå†™ 2 å­—èŠ‚ã€‚