这是一份**代码实现级的深度溯源文档**。

这份文档不再讨论宏观架构，而是**显微镜级别**的实现指南。它将我们之前的**逆向证据（Hex/IDA）**直接映射到 **Rust 函数的具体实现逻辑**上。这也是你编写代码时的“逻辑检查清单”。

---

# AutoThink 底层实现原理与溯源文档 (Code Traceability Spec)

**核心类**：`src/adapters/hollysys/serializer.rs` 中的 `MfcWriter` 和 `PouSerializer`。

---

## 第一部分：基础工具实现的原理 (MfcWriter)

这一层是对 MFC `CArchive` 及其底层行为的复刻。

### 1. `write_mfc_string` (字符串写入)

**逆向发现**：
在 HEX 数据中，字符串 "BOOL" 显示为 `04 42 4F 4F 4C`。

* `04`：长度。
* `42...`: 内容。
* **编码问题**：PLC 软件是老旧 MFC 程序，中文显示乱码，证明它不接受 UTF-8，只接受本地编码（GBK）。

**代码实现逻辑**：

```rust
fn write_mfc_string(&mut self, text: &str) -> Result<()> {
    // 1. 【转码原则】Rust (UTF-8) -> Windows Legacy (GBK)
    // 依据：实测如果不转码，中文变量名在 PLC 中显示乱码。
    let (encoded, _, _) = GBK.encode(text); 
  
    // 2. 【长度前缀原则】MFC CString 标准序列化格式
    // 依据：MFC 源码规定，< 255 字节用 1 字节长度；>= 255 用 FF + 2 字节长度。
    let len = encoded.len();
    if len < 255 {
        self.write_u8(len as u8)?; 
    } else {
        self.write_u8(0xFF)?;
        self.write_u16(len as u16)?;
    }
  
    // 3. 写入内容
    self.write_bytes(&encoded)?;
    Ok(())
}
```

### 2. `write_class_sig` (类签名写入)

**逆向发现**：
在 Network 列表开头，HEX 显示 `FF FF 00 00 0A 00 43 4C 44 4E...` (CLDNetwork)。
这是 MFC `CObject` 序列化的标准头。

**代码实现逻辑**：

```rust
fn write_class_sig(&mut self, class_name: &str) -> Result<()> {
    // 1. 【Magic Number】写入 0xFFFF
    // 依据：HEX 中的 FF FF，MFC 内部标记 tag (wTag)。
    self.write_u16(0xFFFF)?; 
  
    // 2. 【Schema Version】写入 0
    // 依据：HEX 中的 00 00。表示该类的版本号。
    self.write_u16(0)?;  
  
    // 3. 【Class Name】写入类名字符串
    // 依据：紧随其后的 "CLDNetwork" 或 "CLDBox"。
    self.write_mfc_string(class_name)?;
    Ok(())
}
```

---

## 第二部分：业务编排实现的原理 (PouSerializer)

这一层处理最复杂的“混合序列化”逻辑。

### 1. `write_header` (POU 头部 - 混合模式)

**逆向发现**：普通型和安全型在头部结构上有微小但致命的差异（时间戳和标志位）。

**代码实现逻辑**：

```rust
fn write_header(&self, w: &mut MfcWritervec<u8>, pou: &UniversalPou) -> Result<()> {
    // ... 写入名字和 Padding ...

    // 【关键差异点 1：时间戳】
    // 依据：IDA 分析显示 Normal 版调用了 _time64(0)，Safety 版代码中无此调用。
    // HEX 证据：Normal 版 offset 0x0C 处有 4 字节非零整数，Safety 版此处直接是下一个名字。
    match self.variant {
        PlcVariant::Normal => {
            let ts = SystemTime::now()...; 
            w.write_u32(ts)?; // 写入时间戳
        }
        PlcVariant::Safety => {
            // 什么都不写 (Skip)
        }
    }

    // ... 写入重复的名字 ...

    // 【关键差异点 2：安全标志位】
    // 依据：IDA 分析 Safety 版代码显式写入了 `this+24` 处的字节。
    // HEX 证据：Safety 版 offset 0x30 附近，有一串 00 中夹杂了一个 01。
    match self.variant {
        PlcVariant::Normal => {
            w.write_bytes(&[0u8; 24])?; // 全 0
        }
        PlcVariant::Safety => {
            w.write_bytes(&[0u8; 8])?;
            w.write_u8(0x01)?;          // 写入 0x01 (Safety Flag)
            w.write_bytes(&[0u8; 15])?;
        }
    }
    // ...
}
```

### 2. `write_networks` (逻辑体 - 对象模式)

**逆向发现**：这部分是标准的 `CObList` 序列化，包含元素计数和类签名。

**代码实现逻辑**：

```rust
fn write_networks(&self, w: &mut MfcWritervec<u8>, pou: &UniversalPou) -> Result<()> {
    // 1. 【Block Hint】写入 6
    // 依据：HEX 显示 06 00。这是 MFC CList 的预分配大小，不是真实数量，但保持一致比较安全。
    w.write_u16(6)?;

    // 2. 【容器签名】写入 "CLDNetwork"
    // 依据：HEX 显示 FF FF ... CLDNetwork。这也决定了列表里装的是什么类型。
    w.write_class_sig("CLDNetwork")?;

    // 3. 循环写入具体 Network
    for network in &pou.networks {
        self.write_one_network(w, network)?;
    }
    Ok(())
}
```

### 3. `write_one_element` (元件 - 多态处理)

**逆向发现**：

* 功能块（Box）并没有“子元素”，而是把引脚（Pin）作为属性写在自己屁股后面。
* 触点（Contact）有一个字节表示常开/常闭。

**代码实现逻辑**：

```rust
fn write_one_element(&self, w: &mut MfcWritervec<u8>, elem: &LdElement) -> Result<()> {
    // 1. 映射类名
    // 依据：HEX 中出现的 CLDBox, CLDContact 等字符串。
    let class_name = match elem.type_code { ... };
    w.write_class_sig(class_name)?;

    // 2. 写入通用头 (ID, Type, Name)
    // 依据：所有 Element 开头结构一致。
    w.write_i32(elem.id)?;
    w.write_u8(elem.type_code)?;
    w.write_mfc_string(&elem.name)?;

    // 3. 【特化逻辑：功能块】
    if elem.type_code == ElementType::Box {
        w.write_i32(0)?; // Padding
    
        // 依据：HEX 中 MOVE 后面跟着 03 00 (3个引脚)，然后是引脚详情。
        // 引脚不是独立的 Element，而是 Box 的私有数据。
        w.write_u16(elem.pins.len())?; 
        for pin in &elem.pins {
            w.write_i32(2)?; // Pin Type (Hex: 02 00 00 00)
            w.write_mfc_string(&pin.name)?; // "EN"
            w.write_u8(0)?;
            // 关键：变量绑定关系存在这里
            w.write_mfc_string(&pin.variable)?; 
        }
    }
    // 4. 【特化逻辑：触点】
    else if elem.type_code == ElementType::Contact {
        // 依据：Hex 对比发现常开/常闭只有这里一个字节不同。
        w.write_u8(elem.sub_type)?; 
        w.write_i32(-1)?;
    }
}
```

### 4. `write_variables` (变量表 - 自定义模式)

**逆向发现**：变量表没有 `FFFF` 类头，而是直接以 `0x15` (Tag) 开头的一串数据。

**代码实现逻辑**：

```rust
fn write_variables(&self, w: &mut MfcWritervec<u8>, pou: &UniversalPou) -> Result<()> {
    // 依据：C++ 代码中的 switch-case 结构，Case 0x15 处理常规变量。
    for var in &pou.variables {
        w.write_u8(0x15)?; // Tag
        w.write_mfc_string(&var.name)?;
        // ... 其他属性按 HEX 顺序写入 ...
    }
    Ok(())
}
```

---

## 总结

这份文档解释了 **Rust 代码中的每一行“魔法操作”背后的依据**：

1. **为什么写 `0xFFFF`？** -> 因为是 MFC 对象。
2. **为什么写 `0x01`？** -> 因为 IDA 看到 Safety 版写了标志位。
3. **为什么字符串要转码？** -> 因为实测 PLC 软件使用 GBK 编码。
4. **为什么 Box 的引脚单独写？** -> 因为 HEX 显示引脚不是 Child Element，而是 Struct 成员。

这就是 `plc_core` 能够兼容并生成合法文件的根本原因。
