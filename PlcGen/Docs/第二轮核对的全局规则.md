最新完全版 Global Rule Map（凝练版 + 结构化定义 + 必要示例）

目标：用于实现离线解析器/生成器，并能对照反编译与样本快速审计。
约定：u8/u16/u32 皆为 LE；CString 为 MFC CString 序列化；SerVer 为 CAppGlobalFunc::GetSerilizeVersion() 返回值。

0) 基础通用层：Archive / Version / CString
0.1 SerializeVersion（SerVer）来源（确定）

SerVer = dword_10208FB4（运行期全局 dword）

不在文件中，离线解析必须：

外部配置（推荐，最稳）

或启用推断（见 0.4）

0.2 CString（MFC）统一编码（确定）
0.2.1 写长度头 AfxWriteStringLength(len,isUnicode)

若 Unicode：先写 0xFF + 0xFFFE

长度编码：

len < 0xFF：写 1 字节 len

len >= 0xFF：写 0xFF，再：

len < 0xFFFE：写 u16 len

len >= 0xFFFE：写 0xFFFF + u32 len

len == 0xFFFFFFFF：写 u32(-1) + u32(-1)（异常占位）

0.2.2 写字符串体

不含 \0

ANSI：写 len 字节

UTF-16LE：写 len*2 字节

空串：长度头=0，无 padding

0.2.3 读长度头 AfxReadStringLength(&mode)

初始 mode=1

读 1 byte：

!=0xFF：len=该值，mode=1

==0xFF：再读 u16：

==0xFFFE：mode=2（宽字节），继续读 1 byte len；若又是 0xFF 走扩展

!=0xFFFF：len=u16

==0xFFFF：再读 u32 len；若 len==-1 再读额外 u32 做异常检查

0.2.4 CString 读封装族（确定）

sub_10011B50 / sub_100152F0 / sub_10083D30 ... 等价：

len=AfxReadStringLength(&mode)

mode==1 读 len 字节，否则读 len*2

读不足：AfxThrowArchiveException(3,0)

0.2.5 CString 写封装（确定）

sub_10010320(ar, cstr*) 等价：

AfxWriteStringLength(len,isUnicode=0) + Write(len bytes ANSI)

0.3 CArchive::Read/Write（确定）

仅缓冲/IO，不插 marker/padding

读写模式错误抛异常

文件格式只关心调用层写了什么

0.4 SerVer 离线推断策略（规则闭环补齐）

因 SerVer 不落盘，离线解析必须有策略，否则 optional field 会错位。

推荐优先级（从稳到弱）：

外部显式配置 SerVer（工程/版本已知时）

以“可验证字段”试探（解析后做一致性校验）：

Normal InPin/OutPin：是否存在 binding_id（SerVer>=13 才读；写端总写）

CPOU::Serialize：是否存在前导 u32 时间戳（SerVer>=0x0F 必读）

BaseDB：SerVer>=0x34 是否读取 this+76（见 9.3）

失败即 hard-fail：宁可报错，不要“盲跳过”导致雪崩错位

1) MFC Object Stream 层（类头/对象头）——全局基础

这是 Normal/Safety 顶层对象链路的基础（如 CObList::Serialize）

1.1 WriteCount / ReadCount（确定）

WriteCount(n)：

n < 0xFFFF：写 u16 n

否则：写 u16 0xFFFF + u32 n

ReadCount()：

读 u16 tmp，若 !=0xFFFF 返回 tmp

否则读 u32

1.2 类层：WriteClass / ReadClass（确定）

class-map 与 object-map 独立

1.2.1 WriteClass（Storing）

已登记类引用：

id<0x7FFF：写 u16(id|0x8000)

否则：写 u16 0x7FFF + u32(id|0x80000000)

首次类定义：

写 u16 0xFFFF

调 CRuntimeClass::Store（schema + nameLen + nameBytes）

CheckCount + 记录 class-id

1.2.2 CRuntimeClass::Store / Load（确定）

Store：u16 schema + u16 nameLen + nameLen bytes ASCII

Load：读 schema/nameLen/nameBytes（nameLen<0x40），FromName()

1.2.3 ReadClass（确定编码）

先读 u16 tag

tag==0x7FFF：再读 u32 ext -> v5=ext

否则：v5=(tag&0x7FFF)|((tag&0x8000)<<16)

v5<0：class 分支

tag==0xFFFF：新类定义 -> Load()

else：类引用

v5>=0：返回 runtimeClass=NULL，a4 回传 v5（对象引用/NULL 相关）

1.3 对象层：WriteObject / ReadObject（确定）
1.3.1 WriteObject（Storing）

NULL：写 u16 0

已出现对象：写引用 id（u16 或 u16 0x7FFF + u32）

首次对象：

WriteClass(runtimeClass)

CheckCount

记录 object-id

obj->Serialize()

1.3.2 ReadObject（Loading）

ReadClass 决定：

runtimeClass!=NULL：new + 插入 loadArray + Serialize

runtimeClass==NULL：按 id 引用 loadArray[id]（并做 expectedClass 检查）

2) Normal（普通型）元素序列化层

Normal 的元素普遍走 BaseSerialize(sub_100387B0)，且 拓扑 ConnRefs 是关键。

2.1 Normal::CLDElement Base（sub_100387B0）

Storing 顺序：

u32 ID @ +4

u8 TypeID @ +184

CString Name @ +188

CString Comment @ +200

CString Desc @ +204

u32 ConnCount @ +76

ConnRefs[ConnCount]（每项 u32；越界写 -1）

ConnRefs 语义（确定）：

写端用 sub_10037610(connArray,i)：

无表/越界：返回 -1（落盘 0xFFFFFFFF）

否则写 connRefArray[i]

读端 sub_100375D0：自动扩容并用 -1 填充

✅ 结论：Normal 拓扑就是 u32 数组直接落盘。

2.2 Normal::CLDBox（sub_10022A10）

Storing：

BaseSerialize

u32 +356

u32 +360

u8 +400

CString +404

u32 in_count (+292) + in_count * InPin::Serialize()

u32 out_count (+320) + out_count * OutPin::Serialize()

InPins 后立刻 out_count，无 padding

Loading：版本分支

SerVer >= 6 才读 +356/+360

Storing 永远写，Loading 按版本消费（典型兼容模式）

2.3 Normal::CLDInPin / CLDOutPin（sub_10048FB0）——⚠️本节有修正规则

Storing（写端）顺序：

u8 f0 @ +548

u8 f1 @ +549

CString pin_name @ +544

CString bind_value @ +552

u32 binding_id @ +576（写端无条件写）

Loading：

SerVer >= 13 才读 binding_id

否则不读（避免错位）

✅ 2.3.1 P1 修正：OutPin binding_id 不对称问题（你要求写入 Rule Map）

现象证据：

样本显示：输出 pin 若强行读 binding_id 会跨到下一个对象

解析正常的前提是：Output 不读 binding_id

规则修正（正式写入）：

Normal Pin 的“写端无条件写 binding_id”是事实

但离线解析必须支持：

OutPin.binding_id 条件化读取（方向/flag/版本）

当前已知最可靠实现策略：

InPin：按 SerVer>=13 读 binding_id

OutPin：默认 不读 binding_id，除非你后续拿到明确反编译证据证明某分支会读

备注：这是你现在“能跑通样本”的硬规则，等拿到 OutPin 的独立 Serialize 证据再收敛。

2.4 Normal::CLDNetwork / CLDOr / CLDBracket / CLDContact

Network：BaseSerialize + CString + CString

Or：BaseSerialize only

Bracket：BaseSerialize + u8 bracket_type + u32 + subobj + u32 count + pinlikes... (+ optional subobj2)

Contact：BaseSerialize + u8 + CString operand

2.5 Normal：Serialize 槽位 & TextInfo

Serialize = vtable+8（index=2）

CElementTextInfo::Serialize = nullsub（写 0 字节）

2.6 Normal 坐标/布局结论（当前收口）

已展开的 Base/Network/Contact/Or/Box/TextInfo 均不写坐标

若存在布局：应落在 Object Stream 列表里未识别的其他对象类

3) Safety（安全型 LDMDL）元素层 ——核心修正区（P0/P1）

Safety 的最大坑：变量表类型字节与 拓扑重建模型。

3.1 Safety::CLDElement Base（二进制格式最终钉死）

Store / Load 对称：

u32 element_id（证据：this+188 = dword[47]）

u8 flags/typeByte（证据：this+176）

CString name/text @ this+180

u32 conn_count @ this+72

u32 conn_ids[conn_count]（数组指针 this+68；读端扩容并用 -1 初始化）

结论

没坐标

没 child_count

没 network index

Safety 拓扑 = ConnIDs 图

3.2 Safety 派生元素 Serialize（全覆盖映射必须完整）
3.2.1 Safety Factory TypeID（必须 0x00~0x09 全覆盖，P1）
dec	hex	class
0	0x00	CLDElement
1	0x01	CLDOr
2	0x02	CLDAnd
3	0x03	CLDBox
4	0x04	CLDContact
5	0x05	CLDOutput
6	0x06	CLDReturn
7	0x07	CLDJump
8	0x08	CLDAssign
9	0x09	CLDNetwork

硬规则（P1）：

未识别 TypeID：必须 hard-fail

禁止 blind skip（否则 body 长度未知→流错位雪崩）

3.2.2 Safety::CLDNetwork

CLDElementBase

CString label

CString comment

3.2.3 Safety::CLDContact

CLDElementBase

u8 contact_flag @ +196

✅ 无 operand CString

3.2.4 Safety::CLDOutput

CLDElementBase

u8 @ +196

u8 @ +204

3.2.5 Safety::CLDOr / CLDAssign / CLDJump / CLDReturn

Serialize = Base only

即仅 CLDElementBase

3.2.6 Safety::CLDBox（最终版）

CLDElementBase

u8 box_flag @ +356

CString box_text @ +360

u32 in_count

repeat in_count: Safety::InPin

u32 out_count

repeat out_count: Safety::OutPin

✅ InPins 后立即 out_count（无 padding）

3.2.7 Safety::CLDInPin / CLDOutPin（最终版）

InPin：CString @+180 + CString @+184

OutPin：CString @+168 + CString @+172

✅ pin 不含连接、不含 ID、不含 binding_id

✅ Box 连通性仍来自 CLDElementBase.ConnIDs

4) Safety 拓扑与 Network 归属（P0/P1 修正规则正式写入）
4.1 P0：禁止“递归树/child_count”假设用于工程 Serialize

工程 Serialize 路径（你当前样本）必须按：

平铺对象流（hash dump / 无序）

每个对象自身携带 ConnIDs

Network 不携带 children 列表

需要解析后重建归属

child_count/递归树只能属于 Paste/剪贴板路径（若存在），不得混入工程格式。

4.2 Network 归属重建（推荐标准算法）

两遍法：

第一遍：读完整元素池

map[element_id] = element

构图：

对每个 element 的 conn_id：

conn_id != 0xFFFFFFFF 且存在于 map → 加边

建 adj + rev_adj（建议无向 BFS 用）

识别 Network 节点

最强：基于对象 TypeID==0x09（CLDNetwork）

不要用 flags 猜（除非没 TypeID 流）

从每个 Network 做 BFS/DFS

reachable 集合归属 network

冲突策略（元素可达多个 network）

推荐：距离最短优先；距离相同则 network_id 最小或文件顺序最先

无 network 可达：Orphan / 默认网络0

4.3 P1：禁止按读取顺序“挂到当前 network”

Safety 元素不保证在对应 network 后面

顺序挂载必出现 “前三个 network 空” 的症状

5) Safety 变量表（DB typed-list）——P0 根因修正正式写入

这块是你这轮问题的“链路起点”。

5.1 变量表 type byte 的正确语义：容器类型（GetVarType）

规则（必须）：

变量表顶层每条记录结构为：

u8 type_id ← 这是 DB 容器类型，不是“变量条目类型”

DBObject::Serialize body（由 type_id 分派）

合法/常见 type_id 来自 GetVarType：

24 (0x18) : CFunctionBlockDB

11 (0x0B) : CStructDB

9 (0x09) : CArrayDB

13 (0x0D) : CPointerDB

21 (0x15) : CBaseDB（default）

✅ 关键修正（你明确要求写入 Rule Map）

若 type_id 不在 {0x09,0x0B,0x0D,0x18}
一律走 default = CBaseDB

因此 0x06 必须容错 → CBaseDB，而不是判非法中止

这正解释了：count=768 但读到 10 条就停（遇到 0x06 被当非法）。

5.2 typed-list 通用块格式（确定）

u32 total_count

repeat total_count:

u8 type_id

obj = new(type_id->class, default=CBaseDB)

obj->Serialize(ar)

5.3 为什么旧解析器会错位（审计解释链）

把 type byte 当“变量条目类型” → 只认 {0x15/0x0A/0x18}

遇到 0x06：

误判非法 → 中断 → 实际只读 10/768

offset 漂移 → 后续对象流错位

再混入递归树假设 → network elements 空/错挂

未识别 TypeID 再扩大错位雪崩

6) DB 子系统（CBaseDB / CStructDB / CArrayDB / CPointerDB / CStringDB / CFunctionBlockDB）
6.1 GetVarType（确定）
if IsKindOf(CFunctionBlockDB) return 24;
if IsKindOf(CStructDB)        return 11;
if IsKindOf(CArrayDB)         return 9;
if IsKindOf(CPointerDB)       return 13;
else                          return 21; // CBaseDB

6.2 CBaseDB::Serialize（写端固定顺序 + 读端按版本）
6.2.1 写端（Storing）固定顺序（已钉死）

CString +4

CString +8

CString +12（写端可能经 GetStringTOResourceID 映射）

CString +16

u8 +20

CString +32

u8 +48

u32 +52

u32 +56

CString +60

u8 +64

u16 +66

bool(u8!=0) +69

u32 +76

u8 +80

bool(u8!=0) +81

6.2.2 读端（Loading）版本分支要点

SerVer >= 0x34：按“新格式”读，并在该分支里读 +76

<0x34：旧格式有额外兼容读，且 +52/+69/+76 的出现点不同

读完统一后处理：

vtable+100(this,0)

SerVer<0x34 时可能运行期 patch +76（不来自文件）

SerVer>=0x38 才读 +80

SerVer>=0x44 才读 +81

实现建议：写端永远写齐；读端必须严格按版本消费。

6.2.3 BaseDB.this+12 的“语言映射块”分支（你原规则保留）

若 (path为空 或 suffix==".hlf") && SerVer>=0x11：

u32 count

repeat: CString key + CString value

否则：单 CString this+12

6.3 CStructDB::Serialize（member typed-list）

BaseDB

u32 count

repeat count:

(SerVer < 0x2D)：new CBaseDB（无 type byte）

else：读 u8 type → switch(8/9/11/13/24/default) → new

obj->Serialize

sub_10020070(obj)

6.4 CPointerDB::Serialize

BaseDB

写端：CString +88, CString +92

读端：

读 +88

SerVer<0x44：+92=+88

else：读 +92，若空回填 +88

6.5 CArrayDB::Serialize（维度 pair 表 + typed-list + 0x44 兼容）

BaseDB

维度块：

写 u32 pairCount

再写一次同样 u32 pairCount（必须字节复刻，不可优化）

repeat pairCount: u32 a + u32 b

SerVer<0x44：维度 key/value 由 pair Format("%d") 运行期生成插入映射

SerVer>=0x44：从文件读 CString key/value 插入映射

后续 typed-list：

u32 count

repeat: (SerVer<0x2D ? BaseDB : type byte + switch) + Serialize + sub_10020070

6.6 CStringDB::Serialize（与 typed-list 不同：子项无 type byte）

BaseDB

u32 count

CString extra92（SerVer<0x44 用 Format("%d") 回填）

repeat count:

new CBaseDB

Serialize

sub_10020070

6.7 CFunctionBlockDB::Serialize（多段 typed-list + 尾部 KV）

BaseDB

至少 5 段：

每段：u32 countX + repeat(type byte + Serialize)

尾部：

u32 kvCount

repeat kvCount: CString key + CString value（并写入映射/数组）

7) CPOU / CLDPOU 顶层链路（你已有内容合并保留）
7.1 CIECPOU::Serialize = CPOU::Serialize
7.2 CPOU::Serialize（变体 B）

前导 u32 t（time64低32且!=0）

SerVer>=0x0F：读

SerVer<0x0F：按 ProjectType/s_bLibTag/SerVer<0x0A 决定是否读

主字段块（按你现有顺序）

CStringArray 块：u32 N + N*CString

DB typed-list：u32 n + repeat{u8 TypeID + Serialize}

blob1/blob2（ProjectType==1 或 s_bLibTag）

密码/校验块（SerVer>=4，且 SerVer>=0x3C 分支）

末尾两个 flag（SerVer>=0x29）

7.3 CPOUDetail::Serialize（纯 CString 串流）

Loading：次数由外部 this+20 决定，不读 count

Storing：过滤链表项写 CString，不写 count

7.4 CLDPOU::Serialize（顶层结构）

Storing：CPOU::Serialize → tmp(CObList) Serialize → CString + CString → this+135 Serialize

Loading：清理 → tmp Serialize → CString + CString → CalcRelation → Initial → this+135 Serialize

7.5 CObList::Serialize

Storing：WriteCount + WriteObject*

Loading：ReadCount + ReadObject* + AddTail

✅ 本轮新增“核心问题清单”已正式融入 Rule Map 的位置

Safety 变量表 type byte 是容器类型（GetVarType） → 写入 5.1（P0）

0x06 必须 default=CBaseDB → 写入 5.1（P0）

Safety 拓扑=平铺对象流 + ConnIDs 重建，禁止 child_count → 写入 4.1（P0）

Factory TypeID 0x00~0x09 必须全覆盖，未知 hard-fail → 写入 3.2.1（P1）

Safety 网络归属不得按顺序挂载 → 写入 4.3（P1）

Normal OutPin binding_id 不对称 → 写入 2.3.1（P1）

SerVer 离线推断/外部配置闭环 → 写入 0.4（P2）

Safety header_strings 可疑需 P0 修复后复查 → 作为实现注意事项保留（你后续校验用）

你接下来实现/修解析器时的“硬性准则”（避免再雪崩错位）

任何未知 TypeID / DB type_id：hard-fail（除非该字段明确允许 default）

Safety DB type_id：允许 default=CBaseDB（含 0x06）

Safety 工程格式：不允许 child_count 递归树

Safety 网络归属：必须二遍法重建

Normal OutPin binding_id：默认不读（直到你拿到反编译证据能条件化）

---

待补充：梯形图语义规则（当前文档缺失，后续自定义程序功能必须补齐）

1) 触点语义
   - contact_flag 对应 NO/NC/沿触发的规则映射

2) 梯级语义
   - 条件区/动作区的划分规则（哪些元素可作为条件、哪些只能作为动作）

3) 连接语义
   - 串联/并联条件的合法表达与约束

4) 输出语义
   - 并联输出是否允许
   - “输出后继续逻辑”是否允许及其等价转换规则

5) 功能块语义
   - FB/FC/指令的区分标准
   - 是否必须实例、是否允许隐式变量

6) Pin 绑定规则
   - 未绑定时的合法状态与默认处理

7) Network 归属/可达性语义
   - 与连接关系一致性的约束规则（解析/生成一致）

适配器语义规则表 v0（Hollysys/通用）

已确认（结构/字段级，可执行）
| RuleID | 范围 | 规则 | 证据 | 状态 |
|---|---|---|---|---|
| R-CT-01 | Normal/Safety | Contact.sub_type: 0=常开, 1=常闭 | plc_core/src/domain/ast.rs + Docs/解析器底层的相关规则.md | 已确认 |
| R-CO-01 | Normal/Safety | Coil.sub_type: 0=普通线圈, 1=取反线圈 | plc_core/src/domain/ast.rs | 已确认 |
| R-BOX-01 | Normal/Safety | Box 存在 instance 字段；pins=名称+绑定变量 | plc_core/src/adapters/hollysys/parser/mod.rs | 已确认（字段层） |
| R-PIN-01 | Normal | InputPin 在 ser_ver>=13 读 binding_id | plc_core/src/adapters/hollysys/parser/mod.rs | 已确认（字段层） |

待补齐（语义级，影响原子化构造可靠性）
| RuleID | 范围 | 规则 | 缺失点 | 状态 |
|---|---|---|---|---|
| R-CT-02 | Normal/Safety | contact_flag/其他标志 ↔ 沿触发等语义 | flag → 语义映射 | 待确认 |
| R-LD-01 | Normal/Safety | 梯级条件/动作区划分规则 | 哪些元素可作为条件/动作 | 待确认 |
| R-LD-02 | Normal | 串联/并联条件的表达与合法约束 | 连接图语义 | 待确认 |
| R-LD-03 | Normal/Safety | 并联输出是否合法；输出后是否允许继续逻辑 | 动作侧约束 | 待确认 |
| R-FB-01 | Normal/Safety | FB/FC/指令区分标准（是否必须实例） | instance 语义定义 | 待确认 |
| R-PIN-02 | Normal/Safety | pin 未绑定时的合法状态与默认处理 | 空绑定语义 | 待确认 |
| R-NET-01 | Normal | Network 归属/可达性的语义约束 | 条件/动作树构建规则 | 待确认 |







下面是**基于我们当前整个会话新增/确认**的规则提取结果，并按你现有《Global Rule Map》做“**补充**”。
（本轮内容**不需要改动你前面 0~7 的字段级序列化规则**；新增的是“**语义编译层：ConnRefs 图 → tagHccTreeNode 树**”以及“Pin/Assign/Call 的树节点形态”。）

---

下面是把**我们当前会话里已经“确定”的 CalcLogic/树规则**，全部同步进你这份「补充部分 8」里后的**可直接粘贴版**（只写 8 章，不动你 0~7 章）。

---

# ✅ 补充部分：8) 语义编译层（CalcLogic 系列）——ConnRefs 图 → tagHccTreeNode 逻辑树

> 目标：让离线解析器不仅能“读出元素与连线”，还能按与 IDA 一致的方式“生成逻辑树 / 审计树结构”。

---

## 8.1 总原则（核心结论）

**元素之间的“关系/拓扑”（ConnRefs）最终不是 UI 概念，而是被 CalcLogic 编译成 tagHccTreeNode 的“树结构”。**
并且：

* **OR / AND / CONTACT / BOX / ASSIGN / (InPin/OutPin)** 这些“看起来像 UI 元素”的东西，在编译阶段对应：

  * 一类“树节点类型”（node_kind / node_type）
  * 一套固定的“组合/插树规则”（AddNodeToTree 的挂接规则）
* 编译过程有两个“并行维度”：

  1. **表达式树（expression tree）**：用 `AddNodeToTree(linkType=1)` 作为 child 关系挂接
  2. **语句链（statement chain）**：用 `AddNodeToTree(linkType=2)` 作为顺序链追加；`*a2` 永远指向链尾并不断前移

---

## 8.2 tagHccTreeNode 最小结构化认知（审计口径）

### 8.2.1 节点创建族（确定）

* `CIECPOU::NewHccTreeNode(nodeKindByte, hccTypeDword)`
  行为特征：

  * 分配 64 字节（`HccApplyMemory(64)`）
  * `*(_DWORD*)node = nodeKindByte`
  * `*((_DWORD*)node + 1) = hccTypeDword`
  * 其余字段清零
    ✅ 结论：**第 0 字段是 kind（节点大类），第 1 字段是 type（数据类型/运算类型/IEC→HCC 类型类）**

* `CIECPOU::CreateCallTree(pou, argvArray, funcText)`

  * 用于生成 **CALL/操作符/函数块调用** 类节点（Box 主体）

* `CIECPOU::GetAssignNodeByLAndR(pou, textInfo, L, R)`

  * 用于生成 **ASSIGN** 节点（输出赋值语句）

* `CIECPOU::CreateNotNode(pou, baseNodeCopy, &outNode)`

  * 用于生成 **NOT** 节点（Contact 取反、Box 前置取反）

> 审计口径：离线生成器只要能复刻“kind/type + child/chain 挂接方式”，就能与 IDA 结构对齐。

---

### 8.2.2 插树规则（确定）

`CIECPOU::AddNodeToTree(pou, parent, child, linkType)`

* **linkType=1：child 挂接（表达式树）**

  * 代码特征：会扫描 parent 的 child 槽（最多 2 个），把 child 塞进空槽
  * 若已满（>=2），会触发 “Release Dump … IECPOU.cpp:2293” 的报错逻辑
    ✅ 结论：**大量表达式节点都是二叉结构（最多两个 child）**

* **linkType=2：顺序链追加（语句链/执行链）**

  * 代码特征：把 `child` 追加到 `parent` 的“尾链”上，并维护 next/prev 或类似指针
  * 在上层调用里常见模式：

    * `AddNodeToTree(*a2, newNode, 2); *a2 = newNode;`
      ✅ 审计口径：把 `*a2` 当成**当前语句链尾指针**，每追加一个节点就前移。

---

### 8.2.3 label_ptr / 附加链挂接（确定到行为层）

多处出现固定模式：`node[12] = labelNode;`

已确认出现点：

* InPin / OutPin 的 **ForcedValue 节点**：挂 `NextInpinLabelNode / NextOutpinLabelNode`
* Box 的 **NOT 节点**：挂 `GetNextNetWorkLabelNode`

✅ 审计结论（口径级）：
`tagHccTreeNode +12`（按 dword 索引就是 `((DWORD*)node)[12]`）可统一称为 **label_ptr / extra_ptr**：用于挂“标签/标注/附加链入口”。
（它不等同于表达式 child，也不是 statement chain，而是第三条“附加引用”。）

---

## 8.3 已确认的节点 kind（最关键的常量映射）

来自已贴的 CalcLogic 代码（可直接写入规则表）：

* **OR 节点：`NewHccTreeNode(12, 8)`**

  * 来自 `CLDOr::CalcLogic`
  * 组合方式：把前一个子树与新子树分别作为两个 child 挂上去（linkType=1）

* **AND 节点：`NewHccTreeNode(11, prevType)`**

  * 来自 `CLDAnd::CalcLogic`
  * `hccType` 取自 `*((BYTE*)prevNode + 4)`（即前一个节点的 type 字节），表现为“类型沿用/传播”

* **InPin 绑定/比较类节点：`NewHccTreeNode(8, hccType)`**

  * 来自 `CLDInPin::GetPinNodeAndPinLogic`
  * 是“二元节点”：child#1=LHS，child#2=RHS（linkType=1）

> 注：NOT/CALL/ASSIGN 的 kind 常量目前在会话里尚未直接贴出其内部 NewHccTreeNode 立即数，但其“外部挂接规则”已被确定（见 8.4/8.5/8.6）。

---

## 8.4 CLDContact::CalcLogic（确定）

行为（你贴的完整代码已经足够钉死）：

1. `R = CIECPOU::GetRightValueByTextInfo(pou, contact.textInfo)`
2. `*a3 = R`
3. 若 `this+196`（contact_flag）非 0：

   * `CreateNotNode(pou, *a3, out)`
   * `*a3 = outNode`

✅ 审计口径：

* Contact 的 CalcLogic 输出的是“一个表达式节点指针”（放在 `*a3`）
* `contact_flag != 0` 时会把表达式整体包一层 NOT

---

## 8.5 CLDOr / CLDAnd::CalcLogic（确定）

两者结构几乎一致：**线性 fold 合并 children**（从左到右把子表达式折叠成一棵二叉树）。

通用流程：

1. 遍历 children：`for i in 0..childCount-1`
2. 对每个 child 调用其虚函数 `vtable+112`（即 CalcLogic）得到子树 `Ti`
3. 若 i==0：`acc = T0`
4. 若 i>0：新建二元节点 `N`，把 `acc` 和 `Ti` 分别作为 child 加进去（linkType=1），再 `acc = N`
5. 循环结束 `*a3 = acc`（空 children → `*a3=0`）

具体差异：

* OR：`N = NewHccTreeNode(12, 8)`
* AND：`N = NewHccTreeNode(11, prevType)`（type 跟随之前累积节点）

✅ 审计口径：OR/AND 并不是“并联 UI”，而是 **组合表达式树**。

---

## 8.6 CLDBox::CalcLogic 编译流水线（确定的阶段图）

`CLDBox::CalcLogic(this, &stmtTail=*a2, &FBVarPointer, pou)` 结构可抽象成 3 段：

### 阶段 A：前置节点（可选 NOT + label_ptr）（确定到行为层）

触发条件来自 Box 内部逻辑（涉及 child 类型检查、ChildIndex 等）。一旦触发：

1. `CreateNotNode(pou, TreeNodeCopy, &notNode)`
2. `label = GetNextNetWorkLabelNode(pou, this, &tmp)`
3. `notNode[12] = label`
4. `AddNodeToTree(pou, *a2, notNode, 2); *a2 = notNode`

✅ 审计口径：Box 在构建主体前，可能先在语句链上追加一个“条件修饰节点”（NOT + label_ptr）。

---

### 阶段 B：输入 Pin 编译（InPin → PinBind 语句序列）（确定）

Box 会遍历输入 pin（循环从 index=1 开始，直到 in_count-1）：

* `CLDInPin::GetPinNodeAndPinLogic(inpin, a2, &pinNodeOut, modeFlag=this+89, pou)`
* 对某些 modeFlag（你贴的代码里 2/3 分支）会把 `pinNodeOut` 收集进一个参数数组（argv），用于后续 CreateCallTree

✅ 审计口径：

* InPin 不只是“字段”，而是 **生成语句链节点（NODE8）**，并且可能同时作为 CallTree 的参数来源。

---

### 阶段 C：CallTree + 输出赋值（OutPin → Assign 语句）（确定）

Box 根据 `this+89` 走不同主体逻辑：

* `this+89 == 1`：构造 FB 调用（会组 argv 数组，塞 `GetFBVarPointer()` 等），再 `CreateCallTree`
* `this+89 == 2`：`CreateCallTree`
* `this+89 == 3`：`CalcOperatorSelfLogic`
* 其它：退化为 `CreateCallTree`

然后：

* 若 `this+89 <= 1`：把 CallNode 追加到语句链尾：

  * `AddNodeToTree(*a2, CallNode, 2); *a2 = CallNode`

最后对每个 OutPin：

1. `CLDOutPin::GetPinNodeAndPinLogic(outpin, a2, &outValueNode, modeFlag=(BYTE)this+356, pou)`
2. 如果得到了 `outValueNode`（v38 非 0）：

   * `Assign = GetAssignNodeByLAndR(pou, outTextInfo, outValueNode, TreeNodeCopy /*call node copy*/)`
   * `AddNodeToTree(*a2, Assign, 2); *a2 = Assign`

✅ 审计口径：

* Box 的“主体”是 Call/Operator 节点
* OutPin 把“主体结果/上下文”写回到目标变量：表现为 **ASSIGN 语句追加到语句链**

---

## 8.7 Pin 的树节点含义（关键：InPin ≠ OutPin）

### 8.7.1 InPin：生成 nodeKind=8 的二元绑定节点，并插入语句链（确定）

在 `CLDInPin::GetPinNodeAndPinLogic` 的主路径（a4==1）：

* `LHS = CIECPOU::GetLeftValueByVarText(pou)`
* `RHS = CIECPOU::GetRightValueByTextInfo(pou, pinTextInfo)`
* `Bind = NewHccTreeNode(8, hccType)`
* `AddNodeToTree(Bind, LHS, 1)`
* `AddNodeToTree(Bind, RHS, 1)`
* `AddNodeToTree(*a2, Bind, 2); *a2 = Bind`

抽象形状：

```
stmt_chain -> [ NODE8 PinBind ] -> ...
               /           \
            LHS             RHS
```

补充：InPin 内部还存在“空串哨兵”判断（`byte_10063778`）：

* 若 pinText == 空串：多数路径会“什么都不插/只返回成功”
* 若非空串：才会构造 RHS 并生成 NODE8 / 或走特定模式报错

---

### 8.7.2 OutPin：主路径生成 Assign 赋值语句，并插入语句链（确定）

在 `CLDOutPin::GetPinNodeAndPinLogic` 主路径（RightValueByVarText==1 且 outpin 有效）：

* `LHS = GetLeftValueByTextInfo(pou, outTextInfo, ...)`（目标变量/左值）
* `RHS = GetRightValueByVarText(pou)`（右值上下文，常见形态是 “FBInstance.PinName”）
* `Assign = GetAssignNodeByLAndR(pou, outTextInfo, LHS, RHS)`
* `AddNodeToTree(*a2, Assign, 2); *a2 = Assign`
* 若存在 `this+39` 的附加节点：再把它挂到 Assign 后面并前移 `*a2`

抽象形状：

```
stmt_chain -> [ ASSIGN ] -> ...
               /     \
             LHS     RHS
```

---

## 8.8 SimuCompileFlag（仿真强制值）插入规则（确定）

InPin 与 OutPin 都存在同型逻辑：

* `if (CAppGlobalFunc::GetSimuCompileFlag())`

  * `if (CIECPOU::IsBeForcedValueNode(pou, textInfo, &forcedNode))`

    * `label = GetNextInpinLabelNode / GetNextOutpinLabelNode`
    * `forcedNode[12] = label`
    * `AddNodeToTree(*a2, forcedNode, 2); *a2 = forcedNode`

✅ 审计口径：

* 仿真强制值会在语句链中额外插入一条 forced 语句
* forced 语句带 `label_ptr`（node[12]）

---

## 8.9 CLDAssign::CalcLogic（已确认的“角色定位”）

`CLDAssign::CalcLogic` 的行为可以确认一件事：

* 它主要是 **遍历 child 并按顺序调用子元素 CalcLogic（vtable+112）**
* 第 0 个 child 会根据 element type（7/6/5/3）决定是否把 `RightValueByVarText` 作为上下文传入
* 后续 child 按常规路径 CalcLogic

✅ 审计口径：

* “赋值节点（ASSIGN）”**不只**由 CLDAssign 生成；我们已确认 **OutPin 路径会明确生成 ASSIGN**（GetAssignNodeByLAndR）
* CLDAssign 更像是一个“编译顺序/上下文转发器”

---

# ✅ 规则表补充：适配器语义规则表 v0（新增已确认项）

## 已确认（语义编译级，可执行）

| RuleID         | 范围           | 规则                                                                                            | 证据                                            | 状态  |
| -------------- | ------------ | --------------------------------------------------------------------------------------------- | --------------------------------------------- | --- |
| R-CALC-01      | CalcLogic 通用 | CalcLogic 输出两类结构：表达式树（linkType=1）+ 语句链（linkType=2，*a2 链尾推进）                                   | `AddNodeToTree(...,1/2)` + 多处 `*a2=newNode`   | 已确认 |
| R-TREE-01      | TreeNode     | `NewHccTreeNode(kind,type)`：node[0]=kind，node[1]=type；最多两 child（linkType=1）                   | `NewHccTreeNode` + `AddNodeToTree` child 槽满报错 | 已确认 |
| R-LABEL-01     | TreeNode     | `node[12]=label_ptr` 是第三类挂接（label/附加链入口），不属于 child/语句链                                        | InPin/OutPin forced + Box NOT                 | 已确认 |
| R-OR-01        | OR           | OR fold：`NewHccTreeNode(12,8)`；child=(prev, next)                                             | `CLDOr::CalcLogic`                            | 已确认 |
| R-AND-01       | AND          | AND fold：`NewHccTreeNode(11, prevType)`；child=(prev, next)                                    | `CLDAnd::CalcLogic`                           | 已确认 |
| R-CT-LOGIC-01  | Contact      | Contact 输出 RHS=GetRightValueByTextInfo；若 flag(this+196)!=0 则 CreateNotNode 包裹                 | `CLDContact::CalcLogic`                       | 已确认 |
| R-PIN-LOGIC-01 | InPin        | InPin 主路径生成 `NODE8`：child(LHS=GetLeftValueByVarText, RHS=GetRightValueByTextInfo)；并追加语句链      | `CLDInPin::GetPinNodeAndPinLogic`             | 已确认 |
| R-PIN-LOGIC-02 | OutPin       | OutPin 主路径生成 ASSIGN：LHS=GetLeftValueByTextInfo，RHS=GetRightValueByVarText；并追加语句链；可能追加 this+39 | `CLDOutPin::GetPinNodeAndPinLogic`            | 已确认 |
| R-BOX-01       | Box          | Box 三段流水：可选 NOT+label → InPin 编译序列 → CallTree/Operator → OutPin Assign 序列                     | `CLDBox::CalcLogic`                           | 已确认 |
| R-FORCE-01     | Simu         | SimuCompileFlag 下 IsBeForcedValueNode 成功：插 forced 节点并设 `forced[12]=NextLabel`                 | InPin/OutPin 两处同型                             | 已确认 |

---

# ✅ 必要示例（审计用最小树形）

### 示例 1：OR/AND 折叠树（fold）

```
T0 op T1 op T2
=> N1(op, T0, T1)
=> N2(op, N1, T2)
```

### 示例 2：InPin 绑定语句（NODE8）

```
stmt_chain -> NODE8
              /  \
           LHS    RHS
```

### 示例 3：OutPin 赋值语句（ASSIGN）

```
stmt_chain -> ASSIGN
              /   \
            LHS   RHS
```

---

以上就是**把我们当前会话里已确定的 CalcLogic/树规则**全部同步进你这份“补充部分 8”后的版本。你接下来让别的智能体去补“NOT/CALL/ASSIGN 的内部 kind 常量、Box(this+89) 的完整语义映射、ConnRefs→child 的更高层规则”，就能把 8 章补齐到“完全可生成”。
