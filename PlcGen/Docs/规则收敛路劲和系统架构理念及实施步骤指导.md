AutoThink POU 剪贴板序列化协议复刻：分层规则收敛与系统架构设计手册（v1）
0. 背景与目标
0.1 目标

AutoThink 的 POU 在“复制/粘贴”过程中存在一套唯一且确定的序列化/反序列化协议。我们的目标是：

完全复刻该协议：对任意可复制对象（Network/Element/Box/Assign/Variable…），生成 AutoThink 可直接粘贴接受的剪贴板数据；

对上层提供原子化操作 API：让应用层用“添加网络 / 插入 MOV / 连接触点 / 绑定变量 / 设置参数”等方式组合，最终生成合法剪贴板流；

支持 Normal 与 Safety 两种变体，并在版本差异存在时，通过 serialize_version 做可控分支；

为未来“生成定制化 POU 文件/工程资产”奠定同一套统一 AST 与编码器基础。

0.2 非目标（暂缓）

暂不要求理解每个字段的工程语义（例如 geo/布局像素、UI 颜色、内部缓存地址），但要求字节级可复现。

不要求在第一阶段支持所有指令/所有对象类型，优先 MOV/TON/TP/RS/Contact/Coil/Output/Assign/Network 这条主链路。

1. 核心策略：把协议拆成四层（可证伪、可验证）

原则：不要“猜字段含义”，要“复刻字节行为”。
层级拆分的意义是：每一层都能独立验证正确性，避免“局部错位导致全局崩盘”。

L0：字节基础设施层（0 歧义）

负责所有“读/写原始类型”的确定规则：

字节序：Little Endian

字符串族：

MFC CString 的长度编码（u8 / 0xFF + u16）

Safety 常见的 Len32String（u32 长度 + bytes），len==0 必须当空串并吃掉 4 字节

GBK 解码（SimpChinese）作为默认；ASCII/UTF8 仅用于类名/标识符

对齐与 padding：

哪些对象/字段有 4-byte 对齐，哪些绝不对齐

哨兵/标记：

0xFFFF 类签名/对象分隔（你规则里出现频繁）

Safety 拓扑 token：0x8001/0x8003/0x8005/0x8007/0x8009/...，以及新增现象 0x8006（内联元件起始）

变量表前缀：如 00 02 41 78（你已有识别）

L0 成功标准：

在任意偏移，都能稳定判断“接下来像什么”，不会误吞/漏吞导致错位；

能对任意样本做无崩溃解析（即使不理解语义也能跳过/保留）。

L1：容器与对象边界层（CArchive/CObList/ClassTable）

负责“对象从哪里开始、到哪里结束”的规则：

类名/类签名表（ClassTable）与 tag 引用机制

list 计数的多形态（u16/u32/none）与空节点语义

遇到未知类型时的边界策略：

能判定对象边界时：跳到下一个 class sig

不能判定时：保留 raw_bytes（回放 blob），避免整体错位

L1 成功标准：

能把一段剪贴板流稳定分割成对象序列（Network/Element/Box/Assign/…），对象边界不漂移；

UnknownRef/UnknownTail 不影响后续对象解析。

L2：对象结构层（CLDNetwork/CLDElement + 派生）

负责把对象内部字段逐步结构化：

CLDNetwork（Normal/Safety）的 header、topology、tail、variable_table

CLDElement base 字段（id/type_id/name/comment/geo…）

派生类（Contact/Coil/Output/Box/Assign）字段差异与分支条件（variant/serialize_version）

L2 成功标准：

对象可以被完整 encode 回去并被 AutoThink 接受粘贴；

对你“关心字段”（变量绑定/参数/类型）能读写一致。

L3：语义与工程表达层（拓扑/变量层级/资源字符串/多语言）

负责把“工程师理解的梯形图动作”映射成协议表达：

Normal：连接图（conn_count + conn_ids）

Safety：token 拓扑流（branch/series/net_end/inline element）

变量表：按组/按类型/按语言描述组织

资源/注释：实现“像人点出来的一样”的输出（可作为后期优化）

L3 成功标准：

上层原子操作可组合，生成的图结构符合工程直觉；

输出在 AutoThink 中展示一致、可维护、可扩展。

2. 规则收敛方法：差分驱动 + 写入事件追踪（推荐工作流）
2.1 两条验证闭环

你最终要的是 writer，所以验证永远围绕“写入一致性”。

A) Roundtrip（自洽闭环）
decode(golden_bytes) -> AST
encode(AST) -> mine_bytes
decode(mine_bytes) -> AST'
assert AST == AST'


作用：保证你的 AST 与编解码器内部一致，快速回归测试。

B) Golden Diff（字节级对齐闭环，终极裁判）
AutoThink复制得到 golden_bytes
你的encode得到 mine_bytes
hexdiff(golden_bytes, mine_bytes) -> first_diff_offset
定位 offset 属于哪个对象/字段
回到调试器追 Serialize 写入行为


作用：保证你和 AutoThink 行为一致。

规则收敛的正确姿势：每次只修复一个最小差异。
不要一次性“推测很多字段”，否则会把差异叠加，难以定位。

2.2 “写入事件追踪器”：比猜字段快一个数量级

为了避免在 IDA 里纯静态推字段，我们更应该追踪CArchive 真正写了什么字节：

在 x64dbg/x32dbg 做断点：

CArchive::Write

CArchive::Read

AfxWriteStringLength / AfxReadStringLength

必要时：memcpy/WriteFile 或内部缓冲 flush 点

每次命中记录：

Call stack：确定哪个 Serialize 在写

写入长度 / 写入地址 / 写入内容（dump）

this 指针：区分对象实例
-（可选）相关参数：例如写入前的字段值（从 this+offset 取）

最后你会得到一条“写入事件流”，这条流是协议真相。
未知字段不要猜，把它当成“必须复刻的 byte-run”。

3. 系统整体架构（与当前 Rust 设计对齐）
3.1 模块划分（建议）
crate autothink_pou
├── codec/
│   ├── reader.rs        // MfcReader：字节读取、peek、对齐、剩余长度
│   ├── writer.rs        // MfcWriter：字节写入、对齐、字符串族写入
│   ├── primitives.rs    // CString/Len32String/GBK/markers/tokens
│   └── diff.rs          // hexdiff/first-diff定位工具（开发态）
├── model/
│   ├── ast.rs           // UniversalPou/Network/LdElement/Variable 等
│   ├── raw.rs           // RawBlob/UnknownTail/PreservedBytes 结构
│   └── variant.rs       // Variant(Normal/Safety), SerializeVersion
├── parser/
│   ├── section.rs       // 顶层块/类表/对象序列
│   ├── network.rs       // CLDNetwork 解析
│   ├── element.rs       // CLDElement base + 派生类分发
│   └── vartable.rs      // variable table
├── generator/
│   ├── network.rs       // encode CLDNetwork
│   ├── element.rs       // encode CLDElement & derived
│   └── vartable.rs
└── api/
    ├── ops.rs           // 原子化操作 API（builder/patch）
    ├── clipboard.rs     // Windows剪贴板封装（可独立crate）
    └── validate.rs      // 结构校验（拓扑一致性、id唯一性等）


关键点：codec 与 model 必须稳定。
parser/generator 可迭代，api/ops 可随产品需求扩展。

3.2 数据模型设计：AST + 可回放 Blob（保证“完全复刻”）

你现有 UniversalPou 方向正确，但为了 bit-perfect，建议每个对象都能挂载“未知但需保留”的字节。

核心原则：

已理解字段 -> 结构化字段

未理解字段 -> RawBlob 保存，encode 时原样写回（前提：对象未被修改）

当上层修改对象时：

你可以丢弃旧 blob 并用“规范化写法”生成（但会丢失和 AutoThink 的完全一致性）

或者在 blob 内做局部 patch（更难，但更像原生）

推荐结构：

struct LdElement {
  base: ElementBase,
  kind: ElementKind,          // Contact/Coil/Box/Assign/Output...
  raw_extra: Option<Vec<u8>>, // 未解析尾部
  raw_geo: Option<Vec<u8>>,   // geo字段不稳定时可单独保存
}

3.3 变体与版本：显式控制，不要隐式猜测

你已经在函数签名里传 Variant + serialize_version，非常好。建议在顶层也记录：

struct UniversalPou {
  variant: Variant,
  serialize_version: u32,
  networks: Vec<Network>,
  // ...
}


原因：

便于 Golden Diff 定位：同一 AST 在不同版本会写出不同字节

便于做回归测试矩阵：Normal vX / Safety vY

4. 生成器（Writer）优先的设计：从“能粘贴成功”到“像人点出来的一样”
4.1 分阶段目标

阶段 1：粘贴成功（accept）

Box/Assign/Network/Variable 能写入且 AutoThink 接受

未知字段允许 raw 回放

阶段 2：可编辑（editable）

上层原子操作能稳定修改：插入指令、改参数、改变量绑定、改网络连接

阶段 3：原生感（native-like）

geo/布局/多语言描述/变量分组输出稳定，尽量与 AutoThink 生成一致

4.2 ID 与引用一致性（必须内建规则）

工程上最容易踩坑的是：

元件 id 分配与引用一致性

Safety 拓扑 token 流与 inline elements 同步

Normal 连接图 conn_ids 指向合法元素

建议内建 IdAllocator 与 GraphValidator：

IdAllocator：保证全局唯一、可复用策略、可对齐 AutoThink 常见 id 模式（如从某个基准递增）

GraphValidator：encode 前校验，避免生成“结构上不可能”的梯形图

5. 原子化操作 API（应用层接口设计建议）

你说“通过向应用层提供原子化操作，我们可以生成高度定制的 POU”。建议把 API 设计成两级：

5.1 结构原子操作（不会涉及语义解释）

create_network()

insert_box(network_id, box_type, instance_name)

insert_contact(network_id, var_name)

insert_coil(network_id, var_name)

connect(src_elem_id, dst_elem_id, edge_kind)

set_pin_binding(box_id, pin_name, var_or_const)

set_comment(elem_id, text_gbk)

set_geo(elem_id, x, y)（后期）

5.2 语义原子操作（封装常用模式）

emit_mov(dst, src)

emit_ton(q, in, pt, et)

emit_rs(set, reset, q)

emit_branch( ... )（Safety/Normal 都有，内部自动生成 token/conn）

语义原子操作可以产出“最像工程师点击”的结构，让应用层无需理解拓扑表达差异。

6. 高优先级风险点与收敛路线图
P0：不解决就可能粘贴失败

Normal 的 CLDBox padding/未知块（常见指令载体）

CLDAssign 的结构（Safety/Normal 分歧）

Safety token 流边界与 inline element（含 0x8006）

P1：粘贴成功但“不像原生”

geo/布局

header mystery blocks（如果影响版本校验，会升级为 P0）

P2：体验增强

变量表多语言/资源字符串/注释

更多对象类型支持

7. 工程化保障：测试矩阵与回归策略
7.1 样本组织（你已有 Sxx 分区做得很好）

建议每类对象有：

minimal 样本（最小字段）

typical 样本（工程常见）

stress 样本（多网络、多分支、多 box、多变量）

variant 样本（Normal/Safety 同构对比）

version 样本（serialize_version 差异对比）

7.2 自动化测试

Roundtrip tests：每个样本都应该能 decode->encode->decode 等价

Golden diff tests：开发态对比 golden bytes（CI 可选，只在本地跑）

Fuzz（后期）：对 parser 做健壮性（不崩溃、不错位）

8. 实施建议：你现在下一步怎么做（最短路径）

先把 L0/L1 做“绝不漂移”：

Len32String 空串修复（你现状风险极高）

token 0x8006 纳入 inline element

UnknownTail 改为“保留 blob”而不是纯 skip（至少在 Network tail 位置）

建立 Golden Diff 工具：

输出 first diff offset + 前后 64 bytes

能映射 offset -> 解析时记录的“对象区间”（建议 decode 时记录 span）

用写入事件追踪器抓 1~2 个关键 Serialize：

CLDBox::Serialize（Normal）

CLDAssign::Serialize（Safety）

把 MOV_CTRL / TON / TP / RS 这一条链路做通：

能插入、能连线、能绑定变量、能粘贴成功