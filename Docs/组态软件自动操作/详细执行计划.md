# UIA 自动操作模块详细执行计划（仅和利时普通型 AUTOTHINK，其他适配器留空）

> 本计划用于指挥“大模型”推进 UIA 自动操作模块。  
> **当前阶段范围严格限定**：只实现 **和利时普通型 AUTOTHINK** 的自动化能力；  
> Logix5000、TIA Portal（博图）等 **只保留接口与空壳（stub）**，不做任何真实流程与定位规则。

---

## 0. 总要求（大模型必须遵守）

### 0.1 每个任务的回传要求（必须 md）
每个任务必须回传一个 `md` 结果（你会再转发给我），内容必须包含：
- **完成内容摘要**
- **改动清单**（文件路径 + 关键变更点）
- **完成证据**（至少一项）
  - `dotnet build` / `dotnet test` 输出片段
  - 可执行 demo 的控制台日志（例如 READY、RPC 调用、StepLog）
  - JSON-RPC 请求/响应示例（至少 1 组）
- **验收自检**（逐条对照本任务“验收标准”勾选）
- **风险/未决项**

> 禁止只写“做了什么”，必须给**可验证证据**。

### 0.2 本阶段范围与约束（必须）
- 仅实现：**AUTOTHINK（和利时普通型）**
- 其它目标软件（Logix5000/博图等）：
  - 只能提供 **接口 + 空适配器 + 注册**  
  - 禁止实现真实 selector、流程、菜单路径
- UIA core 内禁止 `if software == ...` 的分支逻辑  
  → 软件差异全部进入 `uia_adapter_autothink`
- 原子动作必须在 core：Find/Click/Input/Paste/Wait/RightClick
- 组合流程必须在 autothink 适配器：导入变量、导入程序、编译、硬件、子程序
- 所有动作/流程必须输出 **StepLog**，错误必须统一分类返回

---

## 1. 里程碑（只围绕 AUTOTHINK 普通型）

### Milestone A：协议与可观测性（能跑、能调用、能看日志）
- A1：固化 JSON-RPC 协议（原子动作 + Flow 入口）
- A2：统一 StepLog 与错误分类
- A3：core 原子动作可调用（即便先用最小实现）

### Milestone B：AUTOTHINK 适配器骨架（可选择、可附着、可导航）
- B1：适配器接口 `ISoftwareAdapter` + 注册机制
- B2：`autothink.attach`（识别主窗口/工程上下文）
- B3：基础导航（定位工程树/菜单入口/输出窗口之一）

### Milestone C：AUTOTHINK MVP 闭环（最小可用）
- C1：导入变量表（变量导入完成可检测）
- C2：导入程序（至少一种方式）
- C3：编译（可判断成功/失败并抓取输出）
- C4：硬件配置 + 创建子程序（按你们既定流程拆解）

### Milestone D：工程化增强（稳定性提升）
- D1：等待/重试/超时策略沉入 core
- D2：异常弹窗处理（记录证据）
- D3：最小“录制证据”（保存 selector + StepLog）

---

## 2. 任务清单（交给大模型逐条执行）

> 建议按顺序执行。每完成一个任务都回传 `TASK-XX-result.md`。

---

### TASK-01：解决方案结构收敛（UIA core + AUTOTHINK adapter + apps）
**目标**：建立清晰分层结构，后续可扩展但不实现其它软件能力。

**要求产物（建议结构）**
- `uia_core/`：selector、原子动作、StepLog、错误
- `uia_agent_host/`：stdin/stdout JSON-RPC Host（保留 READY + Ping）
- `uia_adapter_autothink/`：AUTOTHINK 普通型适配器（骨架）
- `uia_adapter_stub_logix5000/`：空壳（仅实现接口，返回 NotImplemented）
- `uia_adapter_stub_tiaportal/`：空壳（仅实现接口，返回 NotImplemented）
- `uia_runner_cli/`：简单 CLI（用于本地调用 RPC 或直接进程内调用）

**验收标准**
- `dotnet build` 通过
- READY + Ping 仍可用（兼容）

**必须回传证据**
- 项目树/文件列表
- build 输出片段

---

### TASK-02：固化 JSON-RPC 协议（最小闭环）
**目标**：把 RPC 的“原子动作 + flow 执行入口”固定下来，避免后续返工。

**必须包含 RPC（最小集）**
- `Ping() -> "pong"`
- `ListAdapters() -> [ "autothink", "stub-logix5000", "stub-tiaportal" ]`
- `SelectAdapter(adapterId) -> ok`
- `RunFlow(flowName, args) -> FlowResult`
- 原子动作（至少保留签名，内部可先 stub）：
  - `Find(selector, scope) -> elementHandle`
  - `Click(elementHandle)`
  - `SetText(elementHandle, text, mode)`
  - `SendKeys(keys)`（支持 CTRL+V）
  - `WaitUntil(condition, timeoutMs)`

**验收标准**
- 文档（md）与 DTO 代码一致
- Ping + ListAdapters 能跑通（真实响应）

**必须回传证据**
- 协议 md 片段
- DTO/接口代码路径
- JSON-RPC request/response 示例

---

### TASK-03：StepLog 与错误模型（现场可定位）
**目标**：所有动作与 flow 都产生结构化日志与统一错误。

**必须包含**
- `StepLog`：stepId、name、paramsSummary、start/end、duration、result、error（可选）、evidence（可选）
- `UiaError` 分类：
  - `ConfigError`
  - `FindError`
  - `TimeoutError`
  - `ActionError`
  - `UnexpectedUIState`

**验收标准**
- 任意一次 RPC 调用返回 `FlowResult` 或 `ActionResult` 时都携带 StepLog（至少一条）
- 失败时返回的错误分类稳定可解析

**必须回传证据**
- 类型定义代码片段
- 一次成功 + 一次失败的返回结构示例（JSON）

---

### TASK-04：Selector DSL 与 ElementHandle（最小可用）
**目标**：确定元素定位与句柄模型，支撑 AUTOTHINK 的定位与后续回放。

**建议 Selector 字段（最小集）**
- `automationId`
- `name`（支持 equals/contains）
- `controlType`
- `withinWindow`（标题/进程名）
- `index`（同级第 N 个）

**验收标准**
- Find 返回 `elementHandle`（可序列化），并能用于后续 Click/SetText
- MVP 允许“句柄失效报错”（先进可选：自动重找）

**必须回传证据**
- Selector/Handle DTO 定义
- 一个 Find + Click 的 JSON-RPC 示例（含返回 handle）

---

### TASK-05：原子动作执行器（core 内实现）
**目标**：在 core 内实现原子动作（至少 Click/SetText/SendKeys/WaitUntil），并输出 StepLog。

**必须实现**
- Click
- SetText（Replace/CtrlAReplace）
- SendKeys（含 Ctrl+V）
- WaitUntil（元素出现/消失 或 enabled 状态之一）

**验收标准**
- 每个动作都有 StepLog
- 超时可配置（默认配置 + 单次调用覆盖）

**必须回传证据**
- 关键代码文件路径 + 摘要
- demo 日志（至少执行一次动作序列）

---

### TASK-06：适配器接口与注册机制（仅 AUTOTHINK 真实现，其他 stub）
**目标**：形成“目标软件适配器”的扩展点，但只让 AUTOTHINK 实际可用。

**必须内容**
- `ISoftwareAdapter`
  - `Id`
  - `AttachAsync(session)`
  - `RunFlowAsync(flowName, args)`
- Registry：注册 autothink + 两个 stub
- stub 适配器：所有 flow 返回 `NotImplemented`（并输出 StepLog）

**验收标准**
- ListAdapters 包含 3 个
- SelectAdapter("autothink") + RunFlow("autothink.attach") 可执行（哪怕只做窗口检查）

**必须回传证据**
- 接口定义 + 注册代码路径
- JSON-RPC：ListAdapters / SelectAdapter / RunFlow 示例

---

### TASK-07：AUTOTHINK 普通型 attach + 基础导航
**目标**：让系统能可靠识别 AUTOTHINK 主窗口，并完成一个基础导航动作。

**最小 flow**
- `autothink.attach`：识别进程/主窗口/工程已打开状态（至少一种）
- `autothink.focusProjectTree` 或 `autothink.openVariableImportDialog`（任选其一）

**验收标准**
- flow 有明确的“预期状态检查”
- 找不到窗口时返回 ConfigError 或 FindError（不能静默失败）

**必须回传证据**
- selector 清单（你们最终采用的识别方式）
- 运行 StepLog（成功/失败至少一条）

---

### TASK-08：AUTOTHINK Flow 1：导入变量表（MVP）
**目标**：跑通 AUTOTHINK 的变量表导入流程（普通型）。

**输入参数**
- `path`（变量表路径）
- `mode`（覆盖/追加/跳过，MVP 可只实现一种）

**验收标准**
- 能检测“导入完成”（对话框关闭/状态提示/输出窗口提示之一）
- 全流程 StepLog 完整

**必须回传证据**
- Flow 步骤列表（md：每步 selector + 预期状态）
- demo 日志（至少一次完整流程）

---

### TASK-09：AUTOTHINK Flow 2：导入程序（至少一种方式）
**目标**：三种方式任选其一打通：
- ST 编辑器粘贴文本（推荐先做）
- 文件导入
- 剪贴板粘贴（前置：剪贴板已写好）

**验收标准**
- 能确认“内容已进入工程”（编辑器内容变化/工程树节点新增之一）
- 出错能定位（Find/Timeout/UnexpectedUIState）

**必须回传证据**
- 选择路径说明 + 步骤日志片段

---

### TASK-10：AUTOTHINK Flow 3：编译并解析结果（MVP）
**目标**：触发编译，判断成功/失败，并抓取最小结果。

**输出**
- `success: bool`
- `errors: string[]`（MVP 可只抓取输出窗口文本片段）
- `warnings: string[]`（可选）

**验收标准**
- 编译结束可检测（状态栏/输出窗口/弹窗）
- FlowResult 能表达成功/失败

**必须回传证据**
- 成功一次的 demo 日志
- 失败处理策略说明（若无法制造失败，可写“如何制造失败”并给出捕获逻辑证据）

---

### TASK-11：硬件配置 + 创建子程序（最小版本）
**目标**：把你们既定的工程动作拆成可复用 flow（先最小版本）。

**建议 flows**
- `autothink.addHardware(hardwareSpec)`
- `autothink.createSubProgram(name, options)`

**验收标准**
- 幂等：已存在则跳过或提示
- 关键节点有预期状态检查（树节点出现/对话框关闭）

**必须回传证据**
- Flow 输入参数模型（DTO）
- demo StepLog（至少执行一次）

---

### TASK-12：工程化增强（等待/重试/弹窗处理）
**目标**：把常见痛点下沉到 core 工具库，提升稳定性。

**至少包含**
- 通用等待：`WaitForDialogOpen/Close`
- 通用弹窗处理：识别确认/错误弹窗并记录证据（截图可选）
- backoff 重试策略（Find/Click 后状态不变）

**验收标准**
- AUTOTHINK flows 中重复 wait/try-catch 明显减少
- 异常弹窗能被记录为 UnexpectedUIState（附证据）

**必须回传证据**
- core 工具库新增 API 说明 + 使用示例
- 一段“改造前后对比”（代码片段或说明）

---

## 3. 回传模板（大模型必须使用）

### `TASK-XX-result.md`
- **Task 编号与标题**：
- **完成摘要**：
- **改动清单**：
  - `path/to/file1`：说明
  - `path/to/file2`：说明
- **关键实现说明**：
- **完成证据**（至少一项）：
  - `dotnet build` / `dotnet test` 输出片段
  - JSON-RPC 示例（request/response）
  - demo 控制台/日志片段（含 StepLog）
- **验收自检**：
  - [ ] 标准 1
  - [ ] 标准 2
- **风险/未决项**：
- **下一步建议**（可选）：

---

## 4. 推荐的最小执行顺序（最快闭环）
1. TASK-01 ~ TASK-06（骨架、协议、日志、原子动作、适配器机制）
2. TASK-07（AUTOTHINK attach）
3. TASK-08/09/10（导入变量/导入程序/编译 MVP）
4. TASK-11（硬件+子程序）
5. TASK-12（工程化增强）

---
