# 通讯地址采集并生成模块：详细执行计划（已补齐边界/三方库/前端组件库约束）

> 本计划用于你把任务下发给“大模型”执行。  
> **本版本已明确**：协议三方库选型、技术边界（Tauri 范围）、前端组件库与页面范围。

---

## 0. 本阶段边界（必须严格遵守）

### 0.1 运行形态边界：只在 Tauri App 内实现（MVP）
- **MVP 只做一个桌面应用：Tauri + Vue3**
- 所有通讯采集逻辑运行在 **Tauri Rust 后端**（`src-tauri`），通过 `tauri::command` 暴露能力给前端
- 前端仅负责配置/展示/导出触发，不允许把通讯协议实现放到前端（避免 Node/浏览器环境差异）
- **不做独立 CLI 工具**（可留接口，但不交付）

> 后续如果需要 CLI 或服务化，再从 `comm_core` 抽出 crate 复用，但 **本阶段不实现**。

---

## 1. 协议与三方库明确选型（必须按此执行）

### 1.1 Modbus 协议库（MVP 固定）
- **Modbus TCP / Modbus RTU：统一使用 Rust 异步生态**
- 选型：
  - `tokio-modbus`：Modbus TCP + Modbus RTU 客户端
  - `tokio-serial`：串口（RTU）传输
  - `tokio`：异步运行时（通过 `tauri::async_runtime` / tokio 兼容方式运行）

> 禁止临时换库（除非遇到无法解决的阻塞问题，且必须在任务回报里写清楚原因与替代方案）。

### 1.2 数据/错误/导出库（MVP 固定）
- 序列化：
  - `serde` + `serde_json`
- 错误：
  - `thiserror`
- 时间戳：
  - `chrono`（或 `time`，二选一；建议 chrono）
- xlsx 导出：
  - **`rust_xlsxwriter`**（Rust 侧直接生成 `.xlsx`）
    - 原因：前端导出受 Node/浏览器限制、兼容性差；Rust 生成更稳定
- 并发与共享状态：
  - `parking_lot`（或标准库 Mutex；建议 parking_lot）
  - `uuid`（用于 sessionId/runId）

---

## 2. 前端技术栈限定（必须按此执行）

### 2.1 框架与组件库（MVP 固定）
- 框架：**Vue 3 + TypeScript + Vite**
- 组件库：**Element Plus**
- 状态管理：**Pinia**
- 表格能力（大数据量点位）：二选一（MVP 先选轻量方案）
  - 方案 A（推荐）：Element Plus Table + 虚拟滚动（先做分页/过滤）
  - 方案 B（如点位>5000 且卡顿）：引入 `vxe-table`（但要写清楚引入原因）

> MVP 默认用方案 A；只有在性能证据明确不足时才允许升级到方案 B。

### 2.2 页面范围（MVP 必做）
- 连接配置页（TCP/RTU）
- 点位列表页（导入/编辑/绑定/批量设置类型与字节序）
- 采集运行页（开始/停止、实时最新值、质量、错误统计）
- 导出页（导出 xlsx：Points/Results/ReadPlan）

---

## 3. 目录结构约束（建议落点，必须清晰）

### 3.1 Rust（src-tauri）建议结构
- `src-tauri/src/comm/`
  - `mod.rs`
  - `model.rs`（Point/Address/DataType/Endian/Quality）
  - `plan.rs`（BatchReadPlan / 聚合与分批）
  - `codec.rs`（bytes ↔ typed value）
  - `driver/`
    - `mod.rs`（Driver trait）
    - `modbus_tcp.rs`
    - `modbus_rtu.rs`
    - `mock.rs`（测试用）
  - `engine.rs`（执行引擎：start/stop、超时重试、统计）
  - `export_xlsx.rs`
  - `tauri_api.rs`（tauri commands，入参/出参 DTO）

### 3.2 前端（Vue）建议结构
- `src/comm/`
  - `api.ts`（invoke 封装）
  - `stores/comm.ts`（Pinia）
  - `pages/Connection.vue`
  - `pages/Points.vue`
  - `pages/Run.vue`
  - `pages/Export.vue`
  - `components/PointEditorDialog.vue`（可选）

---

## 4. 关键业务规则（避免后续扯皮）

### 4.1 地址语义（必须写进文档与 UI 提示）
- 明确 Modbus 地址的“人类输入”与“协议 0-based”差异：
  - UI 输入采用 **1-based（现场常用）** 或明确标注（推荐：UI 1-based）
  - 内部协议请求统一转成 **0-based**
- Area 约束：
  - `coil/discrete` 对应 bit
  - `holding/input` 对应 register（16-bit）

### 4.2 质量（Quality）统一分类（MVP 必须）
- `OK`
- `Timeout`
- `CommError`
- `DecodeError`
- `ConfigError`

### 4.3 执行语义（MVP）
- 允许“部分失败继续跑”：同一轮采集返回所有点位结果，失败点位标记质量
- 输出必须确定性排序：按 `pointId` 或用户列表顺序（固定一种并文档化）

### 4.4 XLSX 列规范与验收（冻结）
- `通讯地址表.xlsx` 中的三张表：`TCP通讯地址表`、`485通讯地址表`、`通讯参数`，列名与列顺序必须与《执行要求.md》中冻结规范逐字匹配，不允许改名、增删或调换顺序。
- Rust 侧导出实现必须以这些冻结 headers 为单一真源（const 常量），UI 或其它模块不得“自行拼接列名”。
- 所有与 XLSX 相关的 TASK（尤其 TASK-10）在验收时必须以“实际导出 headers 与规范逐字对比”作为通过标准之一。

### 4.5 pointKey 与变量名称（HMI）的角色划分
- 每个通讯点位内部必须包含一个系统生成且不可变的稳定键 `pointKey`，用作运行期与结果关联的主键。
- 变量名称（HMI）用于业务语义对齐与对外展示，是导入/导出与回填时的业务键，但不用于运行期结果主键。
- 运行结果（SampleResult 等）必须按 `pointKey` 对齐和存储，导出表仍按冻结的 5 列输出，不要求在这 5 列中包含 `pointKey` 字段。

---

## 5. 大模型执行总规则（每个任务必须回传 md + 证据）

### 5.1 每个任务回传 `TASK-XX-result.md` 必须包含
- 完成摘要
- 改动清单（文件路径 + 关键点）
- 完成证据（至少一项）：
  - `cargo test` / `cargo build` 输出片段
  - 前端 `pnpm build` 或 `pnpm dev` 启动日志片段
  - Tauri invoke 示例（前端调用 + 返回 JSON）
  - 导出 xlsx 的表头文本（每个 sheet 的 header 行必须列出）
- 验收自检（逐条勾选）
- 风险/未决项

---

## 6. 任务清单 v1（历史版本，保留参考；最新执行计划见第 9 节）

> 每完成一个任务回传一个 `TASK-XX-result.md`。

---

### TASK-01：依赖与工程骨架落地（Tauri 范围内）
**目标**：在现有 Tauri+Vue 工程里创建 comm 模块骨架，并引入指定依赖。

**必须完成**
- Rust `Cargo.toml` 引入：tokio / tokio-modbus / tokio-serial / serde / thiserror / rust_xlsxwriter / uuid / parking_lot / chrono
- 创建 `src-tauri/src/comm/` 目录与空模块文件

**验收标准**
- `cargo build` 通过
- 前端 `pnpm dev` 仍可启动（不要求页面完善）

**证据**
- build 输出片段
- 文件树片段（comm 目录）

---

### TASK-02：稳定数据模型（model.rs）+ DTO（tauri_api.rs）
**目标**：确定点位、连接、地址、类型、字节序、质量、结果的通用语言。

**必须包含**
- `ConnectionProfile`：Tcp / Rtu
- `AddressSpec`：area/start/len（UI 1-based 语义写清）
- `DataType`：Bool/Int16/UInt16/Int32/UInt32/Float32（MVP 必须）
- `Endian`：ByteOrder + WordSwap（可表达 ABCD/DCBA 等）
- `CommPoint`：pointId/name/desc/deviceRef + profile + address + parse rules
- `SampleResult`：pointId/valueDisplay/quality/timestamp/durationMs/error?

**验收标准**
- serde JSON 序列化/反序列化可用（给出示例 JSON）
- `cargo test` 至少 1 个：模型序列化 roundtrip

---

### TASK-03：解析器（codec.rs）—— bytes → typed value（含测试向量）
**目标**：实现数据类型 + 字节序正确解析，这是现场核心风险点。

**必须支持**
- Int16/UInt16
- Int32/UInt32（含 word swap）
- Float32（含不同 byte order）
- Bool（先支持 coil/discrete，或 register bit 位二选一，写清楚）

**验收标准**
- 至少 10 组测试向量（覆盖不同 endian/word swap）
- 解析失败返回 DecodeError，不允许 panic

---

### TASK-04：批量读取计划（plan.rs）—— 聚合/分批/节流（纯算法 + 单测）
**目标**：把“灵活批量读取”落为确定性的 `ReadJobs[]`。

**必须实现**
- 按连接 profile 分组（tcp: ip+port+unitId；rtu: port+baud+slaveId 等）
- 按 area + 连续地址聚合（减少请求）
- 分批大小可配置（maxRegs / maxCoils / maxPoints）
- 输出顺序稳定（固定规则：按点位顺序或 pointId 排序）

**验收标准**
- 2 个以上单测：聚合正确、分批正确、顺序稳定

---

### TASK-05：Driver Trait + Modbus TCP 驱动（driver/modbus_tcp.rs）
**目标**：实现 TCP 读取，输出原始 bytes + 映射到点位结果。

**必须内容**
- `trait CommDriver { read(job)->Result<RawJobResult> }`（或等价）
- TCP 客户端基于 `tokio-modbus` 实现 holding/input/coil/discrete 至少两类（MVP 先 holding + coil 也可，但要写明限制）

**验收标准**
- 提供一个 **可运行的 TCP 模拟器**（推荐：tokio task 起一个 mock modbus server，或 driver/mock.rs 注入）
- 单测或 demo：跑一次 read 并得到确定结果

---

### TASK-06：Modbus RTU 驱动（driver/modbus_rtu.rs）+ 可测试策略
**目标**：实现 RTU 读取，并给出“无真实串口时”的可验证测试策略。

**要求**
- 使用 `tokio-serial` + `tokio-modbus` RTU client
- 如果无法稳定做真实 RTU 测试：
  - 必须提供 `driver/mock.rs` 作为替代验证路径
  - 并在 md 里明确“现场验证步骤”（如何连 USB-RS485、如何配置）

**验收标准**
- build 通过
- 至少提供 mock 验证（保证引擎逻辑可测）

---

### TASK-07：执行引擎（engine.rs）—— start/stop、超时、重试、统计
**目标**：把计划跑起来，输出点位最新值与质量统计，支持 UI 实时刷新。

**必须实现**
- `start_run(points, profile, options) -> runId`
- `stop_run(runId)`
- `get_latest(runId) -> Vec<SampleResult>`（分页/过滤可后做）
- timeout + retry policy（次数 + 简单 backoff）
- 统计：total/success/timeout/commError/decodeError

**验收标准**
- 允许部分失败继续跑
- 输出稳定排序
- 提供 demo：mock 驱动制造 OK + Timeout + DecodeError

---

### TASK-08：Tauri API（tauri_api.rs）—— 前后端契约固定
**目标**：把后端能力以 commands 暴露给前端，形成稳定 IPC 契约。

**必须 commands**
- `comm_profiles_save/load`（或简化为单个 profile）
- `comm_points_save/load`
- `comm_plan_build(points, options) -> plan`
- `comm_run_start(points, options) -> runId`
- `comm_run_stop(runId)`
- `comm_run_latest(runId) -> results + stats`
- `comm_export_xlsx(boundPoints, results, plan, outPath) -> outPath`

**验收标准**
- 前端能 invoke Ping 类似命令（可先用 greet 测试替换为 comm 命令）
- 给出 1 组 invoke 示例（request/response）

---

### TASK-09：前端基础框架（Element Plus + Pinia + 路由/布局）
**目标**：前端明确使用 Element Plus，并提供 comm 模块导航与基础页面壳。

**必须完成**
- 引入 Element Plus（含按需或全量，写清）
- 引入 Pinia
- 基础布局：侧边栏菜单（连接/点位/运行/导出）

**验收标准**
- `pnpm dev` 能打开页面并切换路由
- 截图不是必须，但要提供启动日志与页面结构说明

---

### TASK-10：连接配置页（Connection.vue）
**目标**：TCP/RTU 配置可编辑、可保存/加载，校验必填项。

**验收标准**
- UI 可选择 TCP/RTU
- 点击保存会调用 tauri command 并返回成功
- 输入校验（ip/port/串口名/波特率）

---

### TASK-11：点位编辑页（Points.vue）—— 批量设置类型/字节序/地址
**目标**：可新增/编辑/批量修改点位（尤其数据类型与字节序），支持导入/导出 JSON。

**验收标准**
- 表格展示：pointId/name/addr/type/endian
- 批量操作：选择多行 → 设置 DataType/Endian
- 保存后端：invoke `comm_points_save`

---

### TASK-12：运行页（Run.vue）—— 启停采集 + 实时结果 + 统计
**目标**：支持 start/stop，定时刷新 latest results，显示质量与统计。

**验收标准**
- start 返回 runId
- 每 1s（或可配置）刷新结果
- 显示统计：success/timeout/commError/decodeError
- 能在 mock 驱动下展示不同质量

---

### TASK-13：导出页（Export.vue）—— 导出 xlsx（Rust 生成）
**目标**：用户选择导出路径，调用 `comm_export_xlsx` 生成 `.xlsx`。

**xlsx 必含 sheets**
- `Points`
- `Results`
- `ReadPlan`（可选但推荐）

**验收标准**
- 导出成功后 UI 提示导出路径
- 回传证据必须列出每个 sheet 的 header 行文本（从代码常量或日志打印）

---

### TASK-14：最小集成验收脚本（不做自动化测试框架，做“可复现 demo”）
**目标**：给出一套“无真实 PLC 也能演示”的可复现路径（mock server/driver）。

**必须包含**
- 如何启动 mock modbus tcp（自动随 run_start 启动也可）
- Demo 操作步骤（1-2-3）
- 预期输出（包含 OK/Timeout/DecodeError 示例）

**验收标准**
- 任何人按文档步骤都能跑出 demo（至少在开发机环境）

---

## 7. 回传模板（大模型必须原样使用）

### `TASK-XX-result.md`
- **Task 编号与标题**：
- **完成摘要**：
- **改动清单**：
  - `path/to/file1`：说明
  - `path/to/file2`：说明
- **关键实现说明**：
- **完成证据**（至少一项）：
  - `cargo build/test` 输出片段
  - `pnpm dev/build` 输出片段
  - tauri invoke 示例（request/response）
  - xlsx 表头文本（每个 sheet 的 header）
- **验收自检**：
  - [ ] 标准 1
  - [ ] 标准 2
- **风险/未决项**：
- **下一步建议**（可选）：

---

## 8. 推荐最小执行顺序（最快看到 UI + mock 采集 + xlsx）
1) TASK-01 ~ TASK-03（依赖 + 模型 + codec）
2) TASK-04 ~ TASK-05（plan + tcp driver + mock）
3) TASK-07 ~ TASK-08（引擎 + tauri API）
4) TASK-09 ~ TASK-13（前端页面 + 导出）
5) TASK-06（RTU 驱动）与 TASK-14（demo 验收脚本）穿插补齐

---

## 9. 最新任务分解 v2（对齐《执行要求.md》）

> 本节为当前唯一有效的“大模型执行任务清单”，已融合 `执行要求.md` 中的关键约束（XLSX 规范 / 测试策略 / AppData 落盘 等）。
> 第 6 节“任务清单 v1”仅保留作历史参考，可在实际执行时忽略。

### TASK-01：工程基线与依赖引入
- 前端：改为 pnpm，生成 `pnpm-lock.yaml`，删除其他 lockfile
- Rust：`Cargo.toml` 引入 `tokio` / `tokio-modbus` / `tokio-serial` / `thiserror` / `rust_xlsxwriter` / `uuid` / `parking_lot` / `chrono`
- 创建 `src-tauri/src/comm/` 目录与基础骨架文件（model/codec/plan/driver/engine/export_xlsx/tauri_api），但暂不在对外 API 中暴露具体实现。

**验收证据：**
- `pnpm dev`、`pnpm build`
- `cargo build`
- 文件树片段：包含 `src-tauri/src/comm/` 及子模块骨架

### TASK-02：实现模型与 DTO（冻结契约）
- 完成 `CommPoint` / `SampleResult` / `RunStats` / `ConnectionProfile` 等 DTO，其中 `CommPoint` 必须包含系统生成且不可变的 `pointKey`，并包含用于业务对齐的变量名称（HMI）。
- 写入 `schemaVersion = 1` 的持久化结构（profiles/points/plan/results 等 JSON 顶层字段），并约定运行结果与点位通过 `pointKey` 关联。

**验收证据：**
- serde roundtrip test（覆盖带 `pointKey` 的结构）

### TASK-03：codec（>=10 组测试向量）
- 覆盖 `Bool/Int16/UInt16/Int32/UInt32/Float32` 不同字节序与 word swap 场景

**验收证据：**
- `cargo test` 输出（列出测试名）

### TASK-04：plan（聚合/分批/确定性）
- 按连接参数分组（TCP/RTU）
- 按 Area + 连续地址聚合，支持最大寄存器/线圈数配置
- 输出顺序稳定（按点位顺序或 pointId 固定一种）

**验收证据：**
- ≥2 个单测：聚合正确、分批正确、排序稳定

### TASK-05：driver/mock.rs（MVP 必须）
- 提供 mock driver，能在无真实 PLC 环境下模拟 OK / Timeout / DecodeError 等情况
- engine 在 mock 下能产出完整统计

**验收证据：**
- 引擎在 mock 下能产出 OK/Timeout/DecodeError

### TASK-06：modbus_tcp.rs（真实读段）
- 基于 `tokio-modbus` 实现 TCP 读（至少 Holding/Coil）
- 集成到 plan/engine 流程中，可被集成测试框架调用

**验收证据：**
- build 通过
- 集成测试框架能调用（服务未开可 skip）

### TASK-07：modbus_rtu.rs（真实读段）
- 基于 `tokio-serial` + `tokio-modbus` 实现 RTU 读
- 预留环境变量配置口径（见《执行要求.md》测试策略章节）

**验收证据：**
- build 通过
- 集成测试框架能调用（未配置可 skip）

### TASK-08：engine.rs（start/stop/latest/stats，不阻塞 command）
- `comm_run_start` 仅创建 run 并 spawn 后台任务，不得在 command 内同步循环。
- stop 通过 channel / cancellation token 在 1 秒内生效。
- `comm_run_latest` 只读缓存，不触发采集；引擎内部以 `pointKey` 作为 SampleResult 与 CommPoint 的关联键，保证同一 `pointKey` 的结果稳定对齐。

**验收证据：**
- stop 1 秒内生效（mock demo）。
- latest 只读缓存，且 mock 场景下可说明/证明结果是按 `pointKey` 对齐的（变量名称变更不影响关联）。

### TASK-09：tauri_api.rs + lib.rs 注册 commands
- 完成 `comm_profiles_save/load`、`comm_points_save/load`、`comm_plan_build`、`comm_run_start/stop/latest`、`comm_export_xlsx` 等 commands
- DTO 作为稳定契约冻结（后续只允许新增可选字段）

**验收证据：**
- 前端 invoke 一个 comm 命令成功返回 JSON

### TASK-10：export_xlsx.rs（header const + 返回 headers）
- Rust 侧完成 xlsx 导出逻辑，严格遵守《执行要求.md》中冻结的 3 张 sheet 规范，列名与顺序逐字匹配，不允许改名/增删/调序。
- 每个 sheet 的 header 用 `const [&str]` 定义，并在 `comm_export_xlsx` 返回值或日志中输出，作为唯一真源。

**验收证据：**
- 在 `TASK-10-result.md` 结果文档中贴出三张表的实际导出 headers 文本（来自 `comm_export_xlsx` 返回或日志），用于与冻结规范逐字对比。

### TASK-11：前端框架（Element Plus + Pinia + router）
- 引入 Element Plus（按需或全量，写清）
- 引入 Pinia + vue-router，建立基础布局与导航

**验收证据：**
- 路由可切换

### TASK-12：四页面（Connection/Points/Run/Export）
- Connection：TCP/RTU 配置可编辑、保存/加载、校验
- Points：点位表格 + 批量设置类型/字节序/地址 + JSON 导入导出
- Run：start/stop + 定时刷新 latest + 质量/统计展示
- Export：选择导出路径并触发 Rust xlsx 导出

**验收证据：**
- mock 环境完整跑通：导入点位 → start → 看到结果 → 导出 xlsx

### TASK-13：AppData 持久化（profiles/points/plan/results）
- 按 `执行要求.md` 约定路径：`AppData/<app-name>/comm/`
- 固定文件名：`profiles.v1.json`、`points.v1.json`、`plan.v1.json`（可选）、`last_results.v1.json`（可选）
- 每个文件顶层包含 `schemaVersion: 1`

**验收证据：**
- 生成对应文件并包含 `schemaVersion: 1`

### TASK-14：集成测试（你介入跑真服务）
- 按环境变量约定支持真实 Modbus TCP/RTU 服务联调
- 至少一组 TCP 用例能读出 OK（含 16/32/float 任意两类）
- RTU 用例框架存在，待服务准备好后由你介入跑通

**验收证据：**
- 提供运行命令
- 你启动服务后跑出的输出片段（由你粘贴回仓库/文档）

---
