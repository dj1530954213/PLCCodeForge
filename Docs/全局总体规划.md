这是一份非常宏大且严谨的工程规划。作为架构师，我完全认同这种**“谋定而后动”**的策略。我们将通过**“逆向解构 -> 规格定义 -> AI 实施 -> 门径验证”**的闭环流程，确保软件的高质量交付。

为了保证信息的吸收率和执行的准确性，我将这份《AutoThink 全局技术主计划书》分为三个批次交付给你：

*   **批次一（当前）：项目总体架构与里程碑规划**（定义“做什么”和“怎么分层”）。
*   **批次二（稍后）：逆向工程作战手册与协议规格书**（定义“普通型/安全型”的具体二进制规则）。
*   **批次三（最后）：实施级代码规范与验收标准**（指导 AI 写代码，以及定义测试门径）。

---

# 批次一：AutoThink 全局技术主计划书 (Master Plan)

## 1. 项目愿景与定义
开发一套工业自动化编程中台系统（AutoThink），核心基于 **Rust (Core)** + **Tauri (UI)** + **UIA (Automation)** 技术栈。
系统旨在消除人工编写 PLC 程序的重复劳动，实现从**FAT 点表/通讯扫描**到**PLC 最终程序（POU+硬件）**的全链路自动化生成与注入。

## 2. 系统核心架构设计 (The Architecture)
为了应对未来多厂商（和利时普通/安全、西门子等）的扩展需求，系统采用**洋葱式分层架构**。

### 2.1 架构分层图

| 层级 | 模块名称 | 职责定义 | 关键技术栈 |
| :--- | :--- | :--- | :--- |
| **L0** | **System Interaction Layer** | **系统交互层**。负责与操作系统、剪贴板、和利时 GUI 窗口进行物理交互。 | `windows-rs`, `UIA`, `Clipboard API` |
| **L1** | **Protocol Adapter Layer** | **协议适配层**。系统的“翻译官”。屏蔽不同 PLC 型号的二进制差异（普通型 vs 安全型）。 | `Hybrid Serializer`, `Little-Endian`, `GBK Encoding` |
| **L2** | **Universal Model Layer** | **通用模型层**。系统的“大脑”。定义与厂商无关的逻辑 AST（抽象语法树）、硬件树。 | `Rust Enums`, `Tree Structs`, `Traits` |
| **L3** | **Business Logic Layer** | **业务编排层**。系统的“指挥官”。负责 FAT 解析、通讯模板实例化、流程控制。 | `Template Engine`, `State Machine`, `Excel/JSON Parser` |

### 2.2 核心数据流转
1.  **输入**：FAT Excel / 通讯 JSON -> **L3 解析** -> 生成通用 AST (L2)。
2.  **转换**：L2 AST -> **L1 适配器 (普通/安全)** -> 生成二进制 Payload。
3.  **注入**：Payload -> **L0 剪贴板** -> UIA 触发粘贴 -> 和利时软件。

---

## 3. 分阶段实施路线图 (Phased Roadmap)
我们将项目严格切割为四个里程碑（Milestones）。**当前处于 M1 阶段。**

### Milestone 1 (M1): POU 逻辑自动生成与粘贴 (当前重点)
*   **目标**：实现“逻辑代码”的自动化。打通 Rust 到和利时普通型/安全型的剪贴板通路。
*   **核心交付物**：
    *   Rust 库：能生成包含 Network、Element、Variable 的完整 POU 二进制流。
    *   验证工具：能将生成的 HEX 数据反向解析验证。
*   **难点攻关**：普通型与安全型在 POU 头部的二进制差异（Magic Number/Checksum）。

### Milestone 2 (M2): 硬件组态自动化
*   **目标**：实现“硬件配置”的自动化。
*   **核心交付物**：
    *   硬件模型树（Rack/Slot/Module）。
    *   硬件剪贴板生成器（若逆向成功） 或 UIA 结构化配置脚本（若逆向不可行）。

### Milestone 3 (M3): 通讯程序智能生成
*   **目标**：实现“动态逻辑”的自动化。
*   **核心交付物**：
    *   通讯逻辑模板库（Modbus RTU/TCP 轮询模板）。
    *   自动地址分配算法（Auto-Addressing）。

### Milestone 4 (M4): 全流程编排与集成
*   **目标**：交付最终用户产品。
*   **核心交付物**：
    *   集成 UI (Tauri)。
    *   FAT -> 硬件 -> 通讯 -> 逻辑 的全自动流水线。

---

## 4. 协作流程与验证门径 (Workflow & Gates)

我们采用以下流程进行开发，确保每一步都坚实可靠。

### 步骤 1: 逆向与侦察 (Reconnaissance)
*   **执行者**：我（架构师） + 您（测试人员）。
*   **工具**：IDA Pro, x32dbg, 010 Editor, Cheat Engine。
*   **任务**：
    1.  提取和利时 **普通型** 的 POU 剪贴板样本。
    2.  提取和利时 **安全型** 的 POU 剪贴板样本。
    3.  **差分分析**：找出两者在二进制头、加密位、校验和上的不同。
*   **产出**：《协议逆向详细规格书》。

### 步骤 2: 规格下发 (Specification)
*   **执行者**：我（架构师）。
*   **任务**：将逆向结果转化为 Rust 数据结构定义 (`struct`, `enum`) 和序列化逻辑伪代码。
*   **产出**：《Rust 实施详细开发文档》。

### 步骤 3: 代码实现 (Implementation)
*   **执行者**：实施大模型 (AI Coder)。
*   **任务**：根据开发文档，编写 Rust 代码。
*   **产出**：源代码仓库 (Git)。

### 步骤 4: 验证与验收 (Verification & Gatekeeping)
这是必须要守住的门径。
*   **Lvl 1 单元测试**：Rust 测试代码生成的 HEX 是否与 010 Editor 抓取的标准样本字节级一致？
*   **Lvl 2 实机测试**：将生成的 HEX 写入剪贴板，在和利时软件中粘贴，**必须无报错、逻辑图显示正常、编译无错误**。
*   **Lvl 3 安全型验证**：同样的代码/逻辑，切换适配器后，能在安全型软件中粘贴成功。

---

## 5. 当前立即执行的任务 (Immediate Actions)

为了开始 **M1 阶段**，我们需要完成最关键的 **“双版本逆向差分”**。

**请配合我完成以下操作（我们将进入下一批次文档的准备工作）：**

1.  **准备环境**：请确保您电脑上同时安装了 **和利时普通型** 和 **和利时安全型** 两个版本的软件。
2.  **采集样本 (关键)**：
    *   **动作 A**：在**普通型**中新建一个 POU，名为 `TEST_NORM`，里面放一个常开触点 `Tag1`。复制，保存 HEX。
    *   **动作 B**：在**安全型**中新建一个 POU，名为 `TEST_SAFE`，内容完全一样（常开触点 `Tag1`）。复制，保存 HEX。
3.  **提交数据**：请将这两段 HEX 数据发给我。

**一旦拿到这两份数据，我将为您生成《批次二：逆向工程作战手册与协议规格书》，明确指出安全型到底改了哪里。**

您是否同意这个全局计划？如果同意，请开始采集样本。