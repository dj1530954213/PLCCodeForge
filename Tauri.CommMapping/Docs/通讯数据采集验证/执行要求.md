# 通讯地址采集并生成模块：执行计划（已合并“关键硬约束”+ 你的 XLSX 列规范 + 真机联调要求）

> 本计划用于你把任务下发给大模型执行。  
> 已合并三类内容：
> 1) 你冻结的 TCP 地址表列 + 同理 485 地址表列 + 通讯参数表  
> 2) 我之前提出的 8 条“必须修改的关键点”（已写入正文，去掉开放问题）  
> 3) 单测可 mock，但必须支持你提供的 Modbus TCP/RTU 服务进行联调验收

---

## 0. 范围与边界（MVP 必须遵守）

### 0.1 运行形态边界（强制）
- MVP **仅在 Tauri 2 + Vue 3 桌面应用内实现**（`Tauri.CommMapping/src-tauri/` + `src/`）
- 通讯协议（Modbus TCP/RTU）实现必须在 **Rust 后端**（`src-tauri`），通过 `tauri::command` 暴露给前端
- 本阶段不交付独立 CLI/服务化；允许在 Rust 内部按模块化抽离，但不产出独立可执行程序

### 0.2 协议与库选型（强制）
- Modbus TCP/RTU：`tokio-modbus`
- 串口：`tokio-serial`
- 异步：`tokio`（与 Tauri runtime 兼容方式运行）
- 序列化：`serde` + `serde_json`
- 错误：`thiserror`
- 时间戳：`chrono`
- xlsx：`rust_xlsxwriter`
- 并发共享：`parking_lot`
- runId：`uuid`

---

## 1. 必须修改的关键点（已固化为正文硬约束）

### 1) 包管理器与脚本必须固定（禁止混用）
- **统一使用 pnpm**
- 仓库中只允许存在一种 lockfile：`pnpm-lock.yaml`
- 所有脚本命令统一为：
  - `pnpm install`
  - `pnpm dev`
  - `pnpm build`
  - `pnpm tauri dev`

### 2) Tauri 长任务必须后台运行，command 禁止阻塞 UI 线程
- `comm_run_start` **只能创建 run + spawn 后台任务**，不得在 command 内循环采集
- 后台采集必须可 stop（channel / cancellation token）
- stop 必须在 **1 秒内**生效（MVP 验收目标）
- `comm_run_latest` 只读取缓存结果，不触发采集

### 3) “Mock 优先”为硬约束
- MVP 必须交付 `comm/driver/mock.rs`
- 默认 demo 使用 mock，不依赖真实 PLC，不依赖本机开放端口
- “mock modbus tcp server”仅可选增强，不作为验收依赖

### 4) 地址语义必须拍板（删除开放问题）
- **不支持 40001/30001 风格输入**
- UI 只提供：`Area + Start + Len`（其中 Start 为 UI 1-based）
- 内部统一转为 0-based
- Area MVP 先支持 `Holding` + `Coil`
  - `Input/Discrete` 字段保留（接口预留），但 UI 暂不提供入口

### 5) 数据落盘位置必须固定（AppData + 文件名规范）
- 保存目录：`AppData/<app-name>/comm/`
- 固定文件名：
  - `profiles.v1.json`
  - `points.v1.json`
  - `plan.v1.json`（可选）
  - `last_results.v1.json`（可选）
- 每个文件顶层必须包含：`schemaVersion: 1`

### 6) 导出 xlsx 的“表头常量”必须落在 Rust，并作为验收证据输出
- `export_xlsx.rs` 中每个 sheet 的 header 必须用 `const [&str]` 定义
- `comm_export_xlsx` 返回值必须附带 headers（或日志打印 headers，但推荐返回结构里带）

### 7) Tauri API 契约冻结点（避免 DTO 漂移）
以下 DTO 一旦进入 `comm/tauri_api.rs` 视为稳定契约：
- `CommPoint`
- `SampleResult`
- `RunStats`
- `ConnectionProfile`
后续只能新增可选字段，不允许改名/改语义/删字段

### 8) 错误分类与质量（Quality）必须一一对应，且 UI 必须可见
- 每个点位每轮采集必须给：`quality + message`（成功也必须返回 OK）
- UI 结果表必须显示：
  - `valueDisplay / quality / errorMessage / timestamp / durationMs`

---

## 2. 前端技术栈（强制）

- Vue 3 + TypeScript + Vite
- Element Plus
- Pinia
- vue-router
- 表格：Element Plus Table（MVP 先分页/过滤）

---

## 3. XLSX 交付规范（冻结 v1，必须实现）

### 3.1 导出的工作簿与 Sheet（必须）
导出的 `通讯地址表.xlsx` 必须包含：
1) `TCP通讯地址表`
2) `485通讯地址表`
3) `通讯参数`

### 3.2 `TCP通讯地址表`（必须包含并按此顺序）
| 列序 | 列名（冻结） |
|---:|---|
| 1 | 变量名称（HMI） |
| 2 | 数据类型 |
| 3 | 字节序 |
| 4 | 起始TCP通道名称 |
| 5 | 缩放倍数 |

### 3.3 `485通讯地址表`（必须包含并按此顺序）
| 列序 | 列名（冻结） |
|---:|---|
| 1 | 变量名称（HMI） |
| 2 | 数据类型 |
| 3 | 字节序 |
| 4 | 起始485通道名称 |
| 5 | 缩放倍数 |

### 3.4 `通讯参数`（必须包含并按此顺序）
| 列序 | 列名（冻结） | 说明 |
|---:|---|---|
| 1 | 协议类型 | TCP / 485 |
| 2 | 通道名称 | 与起始X通道名称匹配 |
| 3 | 设备标识 | TCP: UnitId；485: SlaveId |
| 4 | 读取区域 | Holding/Input/Coil/Discrete（MVP UI 只暴露 Holding/Coil） |
| 5 | 起始地址 | 内部 0-based |
| 6 | 长度 | 寄存器/线圈数量 |
| 7 | TCP:IP / 485:串口 | TCP 填 IP；485 填 COM |
| 8 | TCP:端口 / 485:波特率 | TCP 端口；485 波特率 |
| 9 | 485:校验 | None/Even/Odd（TCP 留空） |
|10 | 485:数据位 | 8（TCP 留空） |
|11 | 485:停止位 | 1/2（TCP 留空） |
|12 | 超时ms | 单次请求超时 |
|13 | 重试次数 | 失败重试 |
|14 | 轮询周期ms | 引擎轮询周期 |

### 3.5 数据类型与字节序枚举（冻结 v1）
数据类型：
- Bool, Int16, UInt16, Int32, UInt32, Float32

字节序（32-bit）：
- ABCD, BADC, CDAB, DCBA

---

## 4. Rust 分层结构（固定落点）

落点：`Tauri.CommMapping/src-tauri/src/comm/`
- `model.rs`：数据模型 + DTO 内部结构
- `codec.rs`：解析器（字节序/类型/缩放）
- `plan.rs`：批量读取计划（分组/聚合/分批/确定性排序）
- `driver/mod.rs`：Driver trait
- `driver/modbus_tcp.rs`
- `driver/modbus_rtu.rs`
- `driver/mock.rs`：MVP 必须交付
- `engine.rs`：后台采集引擎（start/stop/latest/stats）
- `export_xlsx.rs`：xlsx 导出（header const）
- `tauri_api.rs`：commands + 契约 DTO（冻结）

---

## 5. 测试策略（Mock 单测 + 你介入的真服务联调）

### 5.1 单元测试（必须）
- codec：>=10 组测试向量锁死 endianness/word swap
- plan：>=2 个单测锁死聚合/分批/排序稳定
- engine：用 mock driver 覆盖 OK/Timeout/DecodeError/统计

### 5.2 集成测试（必须支持你提供的 Modbus TCP/RTU 服务）
- 必须新增 `COMM_IT_ENABLE=1` 的集成测试入口
- 不配置环境变量 → 自动 skip（不失败）
- 你启动服务后 → 我们用真实 Modbus TCP/RTU 读回并断言解析正确

环境变量建议（冻结）：
- `COMM_IT_ENABLE=1`
- TCP：
  - `COMM_IT_TCP_HOST`
  - `COMM_IT_TCP_PORT`
  - `COMM_IT_TCP_UNITID`
- RTU：
  - `COMM_IT_RTU_PORT`（COMx）
  - `COMM_IT_RTU_BAUD`
  - `COMM_IT_RTU_PARITY`
  - `COMM_IT_RTU_DATABITS`
  - `COMM_IT_RTU_STOPBITS`
  - `COMM_IT_RTU_SLAVEID`

验收要求：
- 至少一组 TCP 用例能读出 OK（含 16/32/float 任意两类）
- RTU 用例框架必须存在，待你服务准备好后跑通（你介入执行）

---

## 6. 任务分解（大模型执行版）

> 每个任务回传 `TASK-XX-result.md`（必须含：改动清单、build/test 日志、必要时的 headers 输出）

### TASK-01：工程基线与依赖引入
- 前端：改为 pnpm，生成 `pnpm-lock.yaml`，删除其他 lockfile
- Rust：Cargo.toml 引入 tokio/tokio-modbus/tokio-serial/thiserror/rust_xlsxwriter/uuid/parking_lot/chrono

验收证据：
- `pnpm dev`、`pnpm build`
- `cargo build`

### TASK-02：实现模型与 DTO（冻结契约）
- 完成 `CommPoint/SampleResult/RunStats/ConnectionProfile` 等 DTO
- 写入 schemaVersion=1 的持久化结构

验收证据：
- serde roundtrip test

### TASK-03：codec（>=10 组测试向量）
验收证据：
- `cargo test` 输出（列出测试名）

### TASK-04：plan（聚合/分批/确定性）
验收证据：
- 2 个单测 + plan 输出片段

### TASK-05：driver/mock.rs（MVP 必须）
验收证据：
- 引擎在 mock 下能产出 OK/Timeout/DecodeError

### TASK-06：modbus_tcp.rs（真实读段）
验收证据：
- build 通过
- 集成测试框架能调用（服务未开可 skip）

### TASK-07：modbus_rtu.rs（真实读段）
验收证据：
- build 通过
- 集成测试框架能调用（未配置可 skip）

### TASK-08：engine.rs（start/stop/latest/stats，不阻塞 command）
验收证据：
- stop 1s 内生效（mock demo）
- latest 只读缓存

### TASK-09：tauri_api.rs + lib.rs 注册 commands
验收证据：
- 前端 invoke 一个 comm 命令成功返回 JSON

### TASK-10：export_xlsx.rs（header const + 返回 headers）
验收证据：
- 返回/日志打印三张 sheet 的 headers（文本）

### TASK-11：前端框架（Element Plus + Pinia + router）
验收证据：
- 路由可切换

### TASK-12：四页面（Connection/Points/Run/Export）
验收证据：
- mock 环境完整跑通：导入点位→start→看到结果→导出 xlsx

### TASK-13：AppData 持久化（profiles/points/plan/results）
验收证据：
- 生成对应文件并包含 schemaVersion:1

### TASK-14：集成测试（你介入跑真服务）
验收证据：
- 提供运行命令
- 你启动服务后跑出的输出片段（你粘贴回来即可）

---

## 7. 大模型回传模板（必须）
每个任务必须输出：
- 完成摘要
- 改动清单（文件路径）
- build/test 证据
- 验收自检（勾选）
- 风险/未决项

---
